<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Jeremy's Note</title><meta name="description" content="Jeremy Wu's notebook"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://jeremywu.info/atom.xml" title="Jeremy's Note"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/JeremyWuuuuu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/03/12/Rust 控制流/" class="post-title-link">Rust 控制流</a></h2><div class="post-info">2019年3月12日</div><div class="post-content"><p><strong>关键字: </strong> <code>Rust</code> <code>控制流</code></p>
<p>代码跑与不跑, 跑了之后的结果是什么, 都依赖于控制流, Rust 中的控制流分为两大类</p>
<ul>
<li>判断</li>
<li>循环</li>
</ul></div><a href="/2019/03/12/Rust 控制流/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/03/10/Rust 的类型系统/" class="post-title-link">Rust 的类型系统</a></h2><div class="post-info">2019年3月10日</div><div class="post-content"><p><strong>关键字: </strong> <code>Rust</code> <code>类型系统</code></p>
<h2 id="Rust-的类型系统"><a href="#Rust-的类型系统" class="headerlink" title="Rust 的类型系统"></a>Rust 的类型系统</h2><p>Rust 是一门静态编译类的语言, 类型系统的设计可以帮助编译器在编译期内就将”容易出错的代码”暴露给编写程序的人. Rust 的类型系统的设计目标是:</p>
<ul>
<li>安全性</li>
<li>效率</li>
<li>简洁</li>
</ul></div><a href="/2019/03/10/Rust 的类型系统/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/08/06/React源码阅读系列-§2.3-事务机制/" class="post-title-link">React源码阅读系列-§2.3-事务机制</a></h2><div class="post-info">2018年8月6日</div><div class="post-content"><p><strong>关键字: </strong> <code>transaction</code> <code>batch operation</code></p>
<h3 id="事务-Transaction-的原理"><a href="#事务-Transaction-的原理" class="headerlink" title="事务(Transaction)的原理"></a>事务(Transaction)的原理</h3><p>在前面有几节中反复提到了React的事务机制(Transaction), 今天就准备来讲一讲这个事务机制到底是怎么个一回事.<br>用一句简单一点的话来形容这个东西就是: 在调用某一个具体的方法之前与之后, 先调用一系列的处理函数, 类似于<code>npm install</code>对应的<code>npm preinstall</code>和<code>npm postinstall</code>, 分别执行于<code>npm install</code>这个脚本的开始之前与完成之后.</p></div><a href="/2018/08/06/React源码阅读系列-§2.3-事务机制/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/08/04/React源码阅读系列-§2.2-从虚拟DOM到真实DOM/" class="post-title-link">React源码阅读系列-§2.2-从虚拟DOM到真实DOM</a></h2><div class="post-info">2018年8月4日</div><div class="post-content"><p><strong>关键字: </strong> <code>虚拟DOM</code> <code>真实DOM</code></p>
<h3 id="从虚拟DOM节点链接到真实的DOM节点"><a href="#从虚拟DOM节点链接到真实的DOM节点" class="headerlink" title="从虚拟DOM节点链接到真实的DOM节点"></a>从虚拟DOM节点链接到真实的DOM节点</h3><p>当经过挂载/更新, React自己管理的那份DOM节点都会被更新, 无论是从无到有亦或是从旧到新, 都需要经历的从虚拟的DOM链接到真实的DOM当中然后才能被浏览器表现在页面上.<br>那么这一部分功能到底是怎么完成的呢? 从<a href="/2018/07/26/React源码阅读系列-§2.1-生命周期过程详解/">上一节</a>中了解到了React虚拟DOM渲染出来的DOM片段到底长什么样, 接下来就要知道的是这个东西到底是怎么被渲染进入浏览器的DOM对象当中的.</p></div><a href="/2018/08/04/React源码阅读系列-§2.2-从虚拟DOM到真实DOM/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/26/React源码阅读系列-§2.1-生命周期过程详解/" class="post-title-link">React源码阅读系列-§2.1-生命周期过程详解</a></h2><div class="post-info">2018年7月26日</div><div class="post-content"><p><strong>关键字: </strong> <code>生命周期</code> <code>钩子函数</code></p>
<p>在<a href="/2018/07/17/React源码阅读系列-§1.1-生命周期-Lifecycle">§1.1节</a>大概的了解了React的生命周期以及在各个阶段的生命周期钩子函数的调用.</p>
<p>在本节主要详细讲解各个生命周期函数, 以及一些对性能上能够产生优化的细节.</p></div><a href="/2018/07/26/React源码阅读系列-§2.1-生命周期过程详解/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/22/React源码阅读系列-§1.5-ReactDOM-render干了啥/" class="post-title-link">React源码阅读系列-§1.5-ReactDOM.render干了啥</a></h2><div class="post-info">2018年7月22日</div><div class="post-content"><p><strong>关键字: </strong> <code>ReactDOM.render</code> <code>调用栈</code></p>
<p>React应用的启动可谓是相当简单了, 无需过多的配置, 只需要三行代码便可以启动</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line">render((<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>启动!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>), <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>));</span><br></pre></td></tr></table></figure></div><a href="/2018/07/22/React源码阅读系列-§1.5-ReactDOM-render干了啥/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/21/React源码阅读系列-§1.4-来人-给我new一下/" class="post-title-link">React源码阅读系列-§1.4-来人, 给我new一下</a></h2><div class="post-info">2018年7月21日</div><div class="post-content"><p><strong>关键字: </strong> <code>ReactCompositeComponent</code> <code>instantiate</code></p>
<h3 id="让我们先实例化一个组件"><a href="#让我们先实例化一个组件" class="headerlink" title="让我们先实例化一个组件"></a>让我们先实例化一个组件</h3><p><a href="/2018/07/20/React源码阅读系列-§1.3先给我整一个Component/">上一章</a>讲到了, React的<code>Component</code>种类, 但没讲到用户自己写的<code>CustomComponent</code>是怎么被实例化的. 在后面的章节会介绍到关于应用启动的过程到底发生了哪些事情, 在这边就先简单的做一个铺垫. 主要关注在<code>CustomComponent</code>的实例化过程.</p></div><a href="/2018/07/21/React源码阅读系列-§1.4-来人-给我new一下/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/20/React源码阅读系列-§1.3先给我整一个Component/" class="post-title-link">React源码阅读系列 - §1.3 先给我整一个 Component</a></h2><div class="post-info">2018年7月20日</div><div class="post-content"><p><strong>关键字: </strong> <code>BaseComponent</code> <code>CustomComponent</code> <code>PureComponent</code> <code>Statelesscomponent</code></p>
<p>上回书说道, 所有人写的JSX(TSX)代码, 都会被对应的编译器给翻译成<code>React.createElement</code>形式的代码.<br>那么, 一个<code>CustomdComponent</code>是怎么样被React渲染的呢?</p>
<h4 id="来整懂嘛是一个ReactComponent"><a href="#来整懂嘛是一个ReactComponent" class="headerlink" title="来整懂嘛是一个ReactComponent"></a>来整懂嘛是一个ReactComponent</h4></div><a href="/2018/07/20/React源码阅读系列-§1.3先给我整一个Component/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/18/React源码阅读系列-§1.2先有节点后有天 ReactCreateElement/" class="post-title-link">React源码阅读系列 - §1.2先有节点后有天 ReactCreateElement</a></h2><div class="post-info">2018年7月18日</div><div class="post-content"><p><strong>关键词:</strong> <code>ReactElement</code> <code>JSX</code></p>
<h3 id="一切都要从ReactDOM-render讲起"><a href="#一切都要从ReactDOM-render讲起" class="headerlink" title="一切都要从ReactDOM.render讲起"></a>一切都要从ReactDOM.render讲起</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Example <span class="keyword">from</span> <span class="string">'example'</span>;</span><br><span class="line">ReactDOM.render(&lt;Example/&gt;, <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>));</span><br></pre></td></tr></table></figure></div><a href="/2018/07/18/React源码阅读系列-§1.2先有节点后有天 ReactCreateElement/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/17/React源码阅读系列-§1.1-生命周期-Lifecycle/" class="post-title-link">React源码阅读系列 - §1.1 生命周期 Life cycle</a></h2><div class="post-info">2018年7月17日</div><div class="post-content"><p><strong>关键词:</strong> <code>Lifecycle</code> <code>生命周期</code></p>
<h1 id="React的生命周期"><a href="#React的生命周期" class="headerlink" title="React的生命周期"></a>React的生命周期</h1><p>&emsp;&emsp;&nbsp;每一个软件都有他的生命周期, React也不例外, 从React的Tutorial就开始向每一个用户介绍React的生命周期, React的各种内嵌钩子函数的使用. 下面来详细介绍一下React的生命周期到底有哪几个过程.</p></div><a href="/2018/07/17/React源码阅读系列-§1.1-生命周期-Lifecycle/" class="read-more">...阅读全文</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">下一页</a></div><div class="copyright"><p>© 2015 - 2019 <a href="https://jeremywu.info">Jeremy Wu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>