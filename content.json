{"pages":[],"posts":[{"title":"0b0001从分片调度来看React的调度机制","text":"关键字: React Reconciler Scheduler 分水岭 React v16React 16 与之前的版本最大的不同就在于 React 开发核心团队重写了 React 中相当核心的一部分: 更新策略 Before v16Javascript 与渲染引擎的关系因为 Javascript 语言的并发模型的特殊性, Javascript 的代码被放入执行之后, 就会一直跑到结束123while (true) { // do something} 这样的代码会直接导致浏览器没有响应 (不要随意尝试). 由于执行 Javascript 和浏览器页面内容更新计算都是发生在主线程 (Main Thread), 当 Javascript 被执行完, 会生成新的 渲染树, 整个过程如下图 Fig.1 帧更新 (图片来自于 Google Developers) 一般来讲, 这几个流程中的前三个过程都是发生在 CPU 中, 也就是所谓的 Main Thread 中, 剩下两个过程是将计算结果交由 GPU 来执行. 其中, 第三步 layout 也是可以跳过的, 具体的优化步骤可以参见渲染性能优化 React 的更新调度策略React 在 v16 之前的更新调度策略是, 每当有更新发生, 便会从启动本次更新的节点开始, 一直往下计算节点的变更, 直到最后一个节点被计算完 (这是一个递归过程), 才会根据计算出的新 v-dom 树去与旧树比较进行一轮批量更新, 然后该次更新完毕后, 新的渲染树被生成, 最终被画在了屏幕上. 过程如下图所示, 这个更新调度策略被大家称为 栈调度 (stack reconciler) Fig.2 React 更新流程 由于人眼对于动画的感知必须是在 60 fps 下才不会感觉到有卡顿, 也就是说每一帧(画面)更新的时间仅有 1000ms / 60 = ~16ms 左右, 如果更新周期内浏览器主线程并没有时间来更新画面, 便会产生抛弃帧 (frame drop), 也就是说, 当抛弃帧发生时, 用户看到的动画会突然从一个位置飞到另一个位置, 造成卡顿(jank).正是由于 Javascript 的特殊性, 如果当前更新的节点较多 (亦或是计算足够复杂消耗 CPU), 那么即使 React 本身有着足够优越的性能, 也没有办法避免抛弃帧的发生, 一旦更新任务耗时太久, 或者计算非常复杂, 主线程就会被阻塞, 这样一来, 用户的交互也没有办法得到响应 (如: 选择, 输入等).\b正因如此, React 核心团队决定重构 React 的更新调度策略… After v16React Fiber得益于 React 中的 v-dom, React 的性能十分出色, 但由于用户代码对于 React 来说实在是太不可控, 并且 React 也实在是没有办法能够去强制规定使用者的代码风格(质量), 于是 React 的核心团队决定让 React 更快, 并且不会因为更新任务过于繁重从而造成主线程无响应. 所以 Fiber 被引进了 Fiber 是一种编程思想, 是一种非抢占式的多线程模型, 和 CoRoutine 是同一个概念 React Fiber 中的概念是, React Fiber 会主动退出更新任务的运行, 从而交还给浏览器去做更新操作, 当浏览器操作结束后, 会主动将控制权返还给 React Fiber, 进而继续更新工作. React Fiber 的调度器是通过 requestAnimationFrame 和 setTimeout 来实现的. Made with ❤️ by Lin Clark at ReactConf 2017 PhaseFiber 将更新分为两个阶段 Computation这个阶段是 React 计算哪些地方需要更新的阶段, 这个阶段是可以被打断的阶段, 也就是说, 在这个阶段, React 更新每运行一小段时间, 就会将控制权交还给浏览器去响应交互或更新, 然后再空闲时间回到当前的更新阶段, 但是, 由于跟响应用户交互时, 可能会有新的更新插入, 于是之前计算过的那些计算结果可能就没有办法使用了, 之前的计算结果就会被抛弃, 重新进行计算. 并且, 在这些的基础之上, 更新的操作也是有着优先级之分的, 优先级高的更新优先被计算, 优先级低的必须等优先级高的被计算完之后才能被计算.这也是为什么 componentWillMount, UNSTABLE_componentWillUpdate 会被多次调用的原因. Commit这个阶段是实际触发 DOM 更新的阶段, 并且该阶段不会被打断, 也就是说, 一旦进入这个阶段, 更新就会被全部完成, 浏览器在收到更新的通知之后便会去更新页面. Problem经历这两个阶段, 一次更新也就算完成了, 但由于阶段一存在优先级, 一个新的问题又被引入了, 那就是 Starving Task, \b这是由于如果一直有优先级高的更新插入队列中, 那么优先级低的更新就永远无法被触发, 就会引起一系列的问题. UpComing...React Fiber 调度器的实现","link":"/2019/03/31/0b0001从分片调度来看React的调度机制/"},{"title":"React源码阅读系列 - §0 简介 Intro","text":"关键词: React 源码分析 React 源码阅读&emsp;&emsp;&nbsp;最近由于工作变动, 被调到了新的部门, 新的部门里的很多代码并不熟悉, 便只能硬着头皮看下去, 随即发现了一个问题, 跳出舒适圈的我, 在看代码的过程中, 学到了非常多的东西, 想要想办法证明自己, 于是便想开这么一篇React的源码阅读的坑, 准备花一段时间来阅读以及记录自己对源码阅读后的理解和感悟. React版本1234{ \"Name\": \"React\", \"Version\": \"15.6.2\"} 核心概念 (Core Concepts):0. 基础部分 (Pre-requirement) 生命周期 从 JSX (TSX) 到 JS 1. 启动部分 (在应用启动时的代码分析) 从组件 (Component) 到 虚拟节点 (Virtual Node) 从虚拟节点 (Virtual Node) 到 真实DOM节点 (Actual Node) 2. 存在周期 (在存在周期时的代码分析) 事件机制 (Event Handling) 事务处理 (Transaction Operation) 更新操作 (Updating Action)i. 数据更新 (Data Updating)ii. 视图更新 (Layout Updating) 组件间的通信 (Component Communication) Diff的算法分析 (Diff Algorithm) 3. 总结","link":"/2018/07/16/React源码阅读系列-§0 简介 Intro/"},{"title":"React源码阅读系列 - §1.1 生命周期 Life cycle","text":"关键词: Lifecycle 生命周期 React的生命周期&emsp;&emsp;&nbsp;每一个软件都有他的生命周期, React也不例外, 从React的Tutorial就开始向每一个用户介绍React的生命周期, React的各种内嵌钩子函数的使用. 下面来详细介绍一下React的生命周期到底有哪几个过程. 通过一张图来理解: 通过一段注释来理解:1234567891011121314151617181920212223242526/** * ------------------ The Life-Cycle of a Composite Component ------------------ * * - constructor: Initialization of state. The instance is now retained. * - componentWillMount * - render * - [children's constructors] * - [children's componentWillMount and render] * - [children's componentDidMount] * - componentDidMount * * Update Phases: * - componentWillReceiveProps (only called if parent updated) * - shouldComponentUpdate * - componentWillUpdate * - render * - [children's constructors or receive props phases] * - componentDidUpdate * * - componentWillUnmount * - [children's componentWillUnmount] * - [children destroyed] * - (destroyed): The instance is now blank, released by React and ready for GC. * * ----------------------------------------------------------------------------- */ 注:i. 该注释出处为React 源码仓库中的ReactCompositeComponent.jsii. \b\b通过用户编写的Component都是一个Composite Component ReactComponent生命周期以及所对应的钩子函数(Hook) Component 创建:i. Component Constructor - 初始化State Propsii. ComponentWillMount - Hook APIiii. render - 创建节点iv. ComponentDidMount - Hook API Component 更新i. ShouldComponentUpdate - Hook APIii. ComponentWillUpdate - Hook APIiii. render - 更新节点iv. ComponentDidUpdate - Hook API Component 销毁i. ComponentWillUnmount - Hook APIii. 类似 someComponent = null; - 等待GC 下期预告: React.createElement","link":"/2018/07/17/React源码阅读系列-§1.1-生命周期-Lifecycle/"},{"title":"React源码阅读系列 - §1.2先有节点后有天 ReactCreateElement","text":"关键词: ReactElement JSX 一切都要从ReactDOM.render讲起1234import * as React from 'react';import * as ReactDom from 'react-dom';import Example from 'example';ReactDOM.render(&lt;Example/&gt;, document.querySelector('#root')); 从一个错误说起相信不少的人都犯过这样一个错误:123456789import { Component } from 'react';export default class SomeComponent extends Component { render() { return &lt;div&gt;Example&lt;/div&gt;; }}Error: React is not defined. \b明明我这里并没有用到React这个关键字为什么会告诉我说React is not defined呢? \b&emsp;&emsp;&nbsp;答案就是当你写JSX的代码时, \b都是需要通过我们的一些编译工具把JSX代码编译成JavaScript代码, 这样浏览器才能够运行. 而这里的编译过程正好是用到了React这个库上所提供的createElement方法, 所以才会有上面这一行错误. 上面的代码等同于: 1234567// ...省略class SomeComponent extends React.Component { render() { return React.createElement('div', null); }}// ...省略 具体分析createElement方法到底是干了什么createElement方法的方法签名: 1function createElement(type, config, children); 参数名 类型 type string or ReactCompositeComponent config any children any 返回值 ReactElement 从函数签名上可以不难看出, 在构造节点时, React 是需要知道要构造的节点的类型, 节点需要用到的一些属性值, 以及节点的子节点, 然后返回了一个ReactElement实体. 注:&emsp;一个元素节点上的子节点可以看做该节点的属性值(Property). 接下来进入方法内部, 看这个方法到底做了一些什么事情, 该方法最后返回的结果又是什么, 省略掉一部分无关紧要的代码, 某些代码格式为了篇幅稍有整改但不影响正确性.123456789101112131415161718192021222324252627282930313233343536React.createElement = function(type, config, children) { var propName; var props = {}, key = ref = self = source = null; // 传递属性 if (config != null) { // 关键属性, 后面会分析到. if (hasValidRef(config)) { ref = config.ref; } // 判断当前节点是否具有有效的特殊key, key属性也是节点的保留属性, 为React的diff做了非常大的贡献 if (hasValidKey(config)) { key = '' + config.key; } self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; for (propName in config) { // ... 省略属性的复制 } } // 把子节点作为当前根节点上的属性 var childrenLength = arguments.length - 2; if (childrenLength === 1) { props.children = children; } else if (childrenLength &gt; 1) { // 此处代码为本文作者调整 原始代码可参见文末给出地址 props.children = Array.prototype.slice.call(arguments, 2); } // 处理根节点上的默认的属性 if (type &amp;&amp; type.defaultProps) { // ... 省略默认属性的复制 } // 返回一个ReactElement节点 return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);} &emsp;&emsp;&nbsp;透过这个方法其实不难看出, React.createElement整个方法内部, 都是在做一系列的数据处理, 然后把处理好的数据输入给ReactElement这个方法, 通过该方法来构造出一个真正的ReactElement节点. ReactElement到底是个什么东西?&emsp;&emsp;&nbsp;从上面最后一行可以看出来, 最后通过构造方法调用, 返回了一个真实的ReactElement, 这里其实可以看做一个类实例构造类似 省略掉new操作符的类构造器调用\b. 1234567891011// ... 这个markdown的支持可真烂var ReactElement = function(type, key, ref, self, source, owner, props) { return { $$typeof: REACT_ELEMENT_TYPE, type, key, ref, props, _owner: owner };} \b属性名 类型 描述 $$typeof Symbol 标识该对象是一个ReactElement type any 该Element的类型 key string 标识该节点的独有key ref object or function 该节点对象的引用 props object 该节点的所有属性 _owner any 标识该节点的所有者 最后的小测试:尝试人为调用上述的React.createElement方法来得到一个ReactElement然后用树形结构表示出来, 答案在下一章开头.123&lt;div class=\"container\"&gt; &lt;span class=\"sub\"&gt;Text Node&lt;/span&gt;&lt;/div&gt; 下期预告: ReactComponent","link":"/2018/07/18/React源码阅读系列-§1.2先有节点后有天 ReactCreateElement/"},{"title":"React源码阅读系列 - §1.3 先给我整一个 Component","text":"关键字: BaseComponent CustomComponent PureComponent Statelesscomponent 上回书说道, 所有人写的JSX(TSX)代码, 都会被对应的编译器给翻译成React.createElement形式的代码.那么, 一个CustomdComponent是怎么样被React渲染的呢? 来整懂嘛是一个ReactComponent \b\b在开始之前, 先要公布一下上一篇文章的练习题答案. 编译后代码如下:12345678render = () =&gt; React.createElement( 'div', // type {className: 'container'}, // props React.createElement( // - | 'span', //type // |--&gt; children {className: 'sub'}, // props // - | null) // children ); 上面的方法运行出来的结果为: 1234567891011121314151617181920{ $$typeof: Symbol.for('react.element') type: 'div', key: null, ref: null, props: { className: 'container', children: { $$typeof: Symbol.for('react.element') type: 'span', key: null, ref: null, props: { className: 'sub' }, _owner: null } }, _owner: null} &emsp;&emsp;&nbsp;在ES6 A.K.A. ECMAScript2015®以及更高版本的ECMAScript®越来越普及的今天, 并且各种超集(Superset)/下一代编译器(Next Gen Compiler)如: Typescript®, Babel®的普及, 我们更多的是利用class语法来定义我们的ReactComponent, \b\b而非早期版本的React.createClass, 且React.createClass在16.0+版本就已经被宣布废弃, 所以在这边就只对官方提供的三种Component:&emsp;&emsp;&nbsp;&nbsp;i. Component 也叫 BaseComponent&emsp;&emsp;&nbsp;ii. PureComponent&emsp;&emsp;iii. StatelessComponent 也叫 FunctionalComponent做一个简单的分析. i. \bBaseComponent123456789function ReactComponent(props, context, updater) { this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue;}ReactComponent.prototype.isReactComponent = {};ReactComponent.prototype.setState = function () {}; // ...省略实现, 后面会专门讲这个方法ReactComponent.prototype.forceUpdate = function() {}; //.. 同上 ii. PureComponentPureComponent其实基本上跟ReactComponent等价, 唯一不同的地方在这段代码, 而不同点将会在后面的文章当中对其进行介绍.1ReactPureComponent.prototype.isPureReactComponent = true; iii. StatelessComponentStatelessComponent较前两者而言由于不提供任何的生命周期函数, 在特定情况下的性能也许会比前两者稍微好一点. 其更大的优势是在于, 简化了Component本身的一个抽象过程, 可以减少非常多的代码量. 以上是React系统中用户可自定义的三种Component. 这三者其实并没有实际定义所谓的生命周期等函数. 详情请见下回分解. 下期预告: ReactCompositeComponent","link":"/2018/07/20/React源码阅读系列-§1.3先给我整一个Component/"},{"title":"React源码阅读系列-§1.4-来人, 给我new一下","text":"关键字: ReactCompositeComponent instantiate 让我们先实例化一个组件上一章讲到了, React的Component种类, 但没讲到用户自己写的CustomComponent是怎么被实例化的. 在后面的章节会介绍到关于应用启动的过程到底发生了哪些事情, 在这边就先简单的做一个铺垫. 主要关注在CustomComponent的实例化过程. \b\b当我们调用React.render(...)方法的时候, 会调用ReactMount.js中的instantiateReactComponent方法, 该方法中涉及到实例化一个CustomComponent的代码为:123456789101112131415161718function instantiateReactComponent(node, shouldHaveDebugID) { var instance; var element = node; if (typeof element.type === 'string') { instance = ReactHostComponent.createInternalComponent(element); } else if (isInternalComponentType(element.type)) { instance = new element.type(element); if (!instance.getHostNode) { instance.getHostNode = instance.getNativeNode; } } else { instance = new ReactCompositeComponentWrapper(element); } else if (typeof node === 'string' || typeof node === 'number') { instance = ReactHostComponent.createInstanceForText(node); } else { throw new Error(\"Encountered invalid React node of type \" + typeof node ); } } 关键的一行代码在此处:1instance = new ReactCompositeComponentWrapper(element); 关键角色ReactCompositeComponentWrapper是干什么的呢? 又和我们提到的ReactCompositeComponent有什么纠缠不清的关系呢? 下面几行代码就可以告诉你事情的真相:12345678910var ReactCompositeComponentWrapper = function(element) { this.construct(element);};Object.assign( ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, { _instantiateReactComponent: instantiateReactComponent, },); ReactCompositeComponentWrapper就跟他的名字一样, 是对ReactCompositeComponent这个类的一个包装类, 所有的类方法都来自于我们今天要说到的主角ReactCompositeComponent. ReactCompositeComponent\b源码地址: ReactCompositeComponent.js 下面接着对ReactCompositeComponent做一下分析, 某些方法的具体内容会省略掉, 如果有需要可以自行查阅源码当中的具体代码, 方便节省篇幅以及更易于阅读.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var ReactCompositeComponent = { construct: function() {...}, // 用于初始化组件的元信息(Metadata) mountComponent: function() { var inst = this._constructComponent(...); // 生命周期函数的启动入口, var markup; // render方法返回的ReactElement就是这个markup markup = performInitialMount(...); if (inst.componentDidMount) inst.componentDidMount(); // 第三个钩子函数调用 return markup; }, _constructComponent: function() {...}, // 这个方法会调用下面这个方法 _constructComponentWithoutOwner: function() { return new Component(publicProps, publicContext, updateQueue); // 被包起来的Component被实例化 }, performInitialMount: function() { var ins = this._instance; if (ins.componentWillMount) ins.componentWillMount(); // 第一个钩子函数的调用 // 比较重要的地方: 当在初始挂载的阶段如果有发现`setState`方法被调用, 便会通过同步的方式来处理, 很好的避免了setState导致的重新渲染, 来提高整体的性能. if (this._pendingStateQueue) { inst.state = this._processPendingState(inst.props, inst.context); } if (renderedElement === undefined) { // 近似等于: renderedElement = this._instance.render(); renderedElement = this._renderValidatedComponent(); } var child = this._instantiateReactComponent(...) // 递归实例化子组件 var markup = ReactReconciler.mountComponent(child, ...); // 递归得到完整的树. return markup; }, _renderValidatedComponent: function() { return this._renderValidatedComponentWithoutOwnerOrContext(); }, _renderValidatedComponentWithoutOwnerOrContext: function() { return this._instance.render(); // 第二个钩子的调用 }, receiveComponent: function(...) { // 调用该方法来更新Component this.updateComponent(...); }, updateComponent: function(...) { // 后面会讲到这些更新条件如何被满足 if (willReceive &amp;&amp; inst.componentWillReceiveProps) { inst.componentWillReceiveProps(); // 第四个钩子函数的调用 } var shouldUpdate = inst.shouldComponentUpdate(); // 第五个钩子函数调用 if (shouldUpdate) this._performComponentUpdate(); }, _performComponentUpdate: function() { inst.componentWillUpdate(...); // 第六个钩子函数的调用. this._updateRenderedComponent(...); // 更新; 内部调用第七个钩子函数 Component.render(); inst.componentDidUpdate &amp;&amp; inst.componentDidUpdate(); // 第八个个钩子函数调用 }, // 里面是Component更新的操作 简单来说就是销毁掉原有的节点, 然后重新实例化新的节点挂载. _updateRenderedComponent: function() { }, unmountComponent: function() { } // 递归卸载节点, 调用子节点的 componentWillUnmount方法} 本章小结:ReactCompositeComponent 的内容基本就是挂载/更新/卸载等操作. \b除了CompositeComponent, 在instantiateReactComponent方法中, 能够看到React中一共有4种Component类型. ReactCompositeComponent InternalComponent. // 可以理解为React的官方标准组件库 UserDefinedComponent // 用户自定义 ReactDOMComponent // DOM节点相关的Component, 自定义的Component最后都会被处理成该类型的 ReactTextComponent // 字面量节点, 如 &quot;Some string&quot; &quot;12312&quot; ReactEmptyComponent // 空节点 下期预告: 从React.render()的调用开始, 到底发生了什么?","link":"/2018/07/21/React源码阅读系列-§1.4-来人-给我new一下/"},{"title":"React源码阅读系列-§1.5-ReactDOM.render干了啥","text":"关键字: ReactDOM.render 调用栈 React应用的启动可谓是相当简单了, 无需过多的配置, 只需要三行代码便可以启动 123import * as React from 'react';import {render} from 'react-dom';render((&lt;div&gt;启动!&lt;/div&gt;), document.querySelector('#root')); ReactDOM.render方法一共接受三个参数:1ReactDOM.render = function(nextElement, container, callback) {...}; 第一个参数为需要渲染的ReactElement;第二个参数是用来挂载渲染好的DOM节点的Container;第三个参数为一个可选参数,用来接受一个在该方法结束之后被调用的一个Function; 结合上一些代码来了解一下, 该方法被调用时到底经过了哪一些过程. ReactDOM.render()的调用栈为了更好的能够理解这一章的内容, 上一篇已经通过了ReactCompositeComponent做了一轮铺垫, 在有了上一篇的知识的基础上, 本篇内容的复杂度将会大大降低. 所有内容均建立在没有启动ServerSideRendering的情况之下. 通过文字来描述: render方法首先会调用_renderSubtreeIntoContainer来启动调用过程, 该方法会调用_renderNewRootComponent方法. 并且会调用render传入的callback方法. _renderNewRootComponent会调用instantiateReactComponent()方法来实例化被传入的组件. 然后得到对应的组件树. 把得到的组件树通过ReactUpdates.batchedUpdates更新到DOM中.i. ReactUpdates.batchedUpdates会通过调用batchingStrategy.batchedUpdates来调用batchedMountComponentIntoNode方法. 这里有关于ReactTransaction的概念, 在后面一章里面会讲到.ii. 这边需要关注的方法就是batchedMountComponentIntoNode方法. batchedMountComponentIntoNode调用mountComponentIntoNode, 然后紧接着ReactReconciler.mountComponen被调用. 到这里开始就是上一章讲过的那一部分内容了. 实例内部的生命周期被调用, 然后返回了对应的DOM结构. 返回的DOM结构被通过ReactMount._mountImageIntoNode方法挂载进入真正的DOM中. 至此, 整个调用过程结束. 通过一张流程图来描述:12345678910111213141516171819202122232425262728↓: 表示调用 开始 ↓ ReactMount.render ↓ReactMount._renderSubtreeIntoContainer ↓ReactMount._renderNewRootComponent // 触发创建真实DOM节点 ↓instantiateReactComponent // 创建真实DOM ↓batchedMountComponentIntoNode ↓mountComponentIntoNode ↓ ReactReconciler.mountComponent ↓ReactCompositeComponent.mountComponent ↓ReactCompositeComponent.performInitialMount ↓ReactMount._mountImageIntoNode ↓ \\ setInnerHTML |---- 通过根节点挂载 ↓ /ReactDOMComponentTree.precacheNode // 保存virtualDOM ↓ 结束 通过一张关系图来描述 小结&amp;预告:通过了解框架中封装的方法内部的调用实现, 可以更直观的去了解框架, 能够在后续的工作当中让自己写出来性能更加高的代码, 并且对整体应用能有所规划. \b 下期预告: React生命周期的具体分析.","link":"/2018/07/22/React源码阅读系列-§1.5-ReactDOM-render干了啥/"},{"title":"React源码阅读系列-§2.2-从虚拟DOM到真实DOM","text":"关键字: 虚拟DOM 真实DOM 从虚拟DOM节点链接到真实的DOM节点当经过挂载/更新, React自己管理的那份DOM节点都会被更新, 无论是从无到有亦或是从旧到新, 都需要经历的从虚拟的DOM链接到真实的DOM当中然后才能被浏览器表现在页面上.那么这一部分功能到底是怎么完成的呢? 从上一节中了解到了React虚拟DOM渲染出来的DOM片段到底长什么样, 接下来就要知道的是这个东西到底是怎么被渲染进入浏览器的DOM对象当中的. ReactMount._mountImageIntoNode此处用挂载时的函数方法来举例, 更新的挂载操作类似, 但我们只关注更新操作的更新策略. ReactMount.mountComponentIntoNode方法的最后通过调用ReactMount._mountImageIntoNode来把渲染好的DOM片段链接到DOM当中去12345678910111213141516171819ReactMount._mountImageIntoNode = function( markup, container, instance, shouldReuseMarkup, transaction, ) { // ... 省略掉一些ServerRendering的处理代码以及开发阶段报错的代码 if (transaction.useCreateElement) { while (container.lastChild) { container.removeChild(container.lastChild); } DOMLazyTree.insertTreeBefore(container, markup, null); } else { setInnerHTML(container, markup); ReactDOMComponentTree.precacheNode(instance, container.firstChild); } }}; 在这个方法里通过DOMLazyTree.insertTreeBefore方法, 把渲染好的DOM片段塞到了真实的DOM里1234567891011121314151617181920// 此处方法经过一些特殊处理... 来处理M$的兼容性var insertTreeBefore = function( parentNode, tree, referenceNode,) { if ( tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || (tree.node.nodeType === ELEMENT_NODE_TYPE &amp;&amp; tree.node.nodeName.toLowerCase() === 'object' &amp;&amp; (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) ) { insertTreeChildren(tree); parentNode.insertBefore(tree.node, referenceNode); } else { parentNode.insertBefore(tree.node, referenceNode); insertTreeChildren(tree); }}; parentNode.insertBefore方法就是DOM方法Node.insertBefre方法. 到这边结束之后渲染好的DOM片段就被正式挂载进入了DOM当中. 下节预告: React中的事务处理.","link":"/2018/08/04/React源码阅读系列-§2.2-从虚拟DOM到真实DOM/"},{"title":"React源码阅读系列-§2.3-事务机制","text":"关键字: transaction batch operation 事务(Transaction)的原理在前面有几节中反复提到了React的事务机制(Transaction), 今天就准备来讲一讲这个事务机制到底是怎么个一回事.用一句简单一点的话来形容这个东西就是: 在调用某一个具体的方法之前与之后, 先调用一系列的处理函数, 类似于npm install对应的npm preinstall和npm postinstall, 分别执行于npm install这个脚本的开始之前与完成之后. 用一幅图来说明:123456789101112131415161718192021222324/** * wrappers (injected at creation time) * + + * | | * +-----------------|--------|--------------+ * | v | | * | +---------------+ | | * | +--| wrapper1 |---|----+ | * | | +---------------+ v | | * | | +-------------+ | | * | | +----| wrapper2 |--------+ | * | | | +-------------+ | | | * | | | | | | * | v v v v | wrapper * | +---+ +---+ +---------+ +---+ +---+ | invariants * perform(anyMethod) | | | | | | | | | | | | maintained * +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt; * | | | | | | | | | | | | * | | | | | | | | | | | | * | | | | | | | | | | | | * | +---+ +---+ +---------+ +---+ +---+ | * | initialize close | * +-----------------------------------------+ */ 该图版权属于React开发团队所有. 在某些框架的源码中其实也依稀可见这种处理的思想, 类似但不仅限于对Array的Native方法的劫持调用, 如Vue早期版本当中对Array的处理用来添加函数处理. 事务类的接口定义:1234567891011type TransactionImpl = { reinireinitializeTransaction: () =&gt; void; // 重置wrapper _isIntransaction: boolean; // transaction调度时标识符 getTransactionWrappers: () =&gt; Array&lt;TransactionWrapper&gt;; // 拿到所有wrapper isInTransaction: () =&gt; boolean; // 得到_isIntransaction属性 perform: &lt;A, B, C, D, E, F, G, T: (a: A, b: B, c: C, d: D, e: E, f: F) =&gt; G&gt; (method: T, scope: any, a: A, b: B, c: C, d: D, e: E, f: F) =&gt; G; // 事务调度 // 在perform方法中先后调用 this.initializeAll(index) 和 this.closeAll(index) initializeAll: (startIndex: number) =&gt; void; // 执行所有wrapper中的initialize方法 closeAll: (startIndex: number) =&gt; void; // 执行所有wrapper中的close方法} 在React整个系统中一共实现了3种事务操作类(服务端渲染和ReactNative不算). ReactUpdatesFlushTransaction ReactBatchingStrategyTransaction ReactReconcileTransaction 每一种事务类都负责处理对应的操作(下面会说到). ReactUpdates.batchedUpdates()方法被用来启动整个更新的操作, 然后把这个操作的分配工作交给ReactBatchingUpdateStrategyTransaction ReactBatchingUpdateStrategyTransaction的Wrapper实现以及功能:1234567891011121314151617181920212223242526272829303132import TransactionImpl from 'Transaction';// 定义Wrapper1号var RESET_BATCHED_UPDATES = { initialize: emptyFunction, // 空方法 close: function() { // 标志位置回false ReactDefaultBatchingStrategy.isBatchingUpdates = false; },};// 定义Wrapper2号var FLUSH_BATCHED_UPDATES = { initialize: emptyFunction, // 空方法 // 更新DOM close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),};var TRANSACTION_WRAPPERS: Array&lt;TransactionWrapper&gt; = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];}// 当在调用这个transaction.perform方法的时候实际上是这样的:/** * * * +----------------------+ +---------------------+ +----------+ * perform -&gt; |FLUSH_BATCHED_UPDATES.| -&gt; |REST_BATCHED_UPDATES.| -----&gt; | method | * | initialize | | initialize | | | * +----------------------+ +---------------------+ +----------+ * | * +----------------------+ +----------------------+ | * |REST_BATCHED_UPDATES. | |FLUSH_BATCHED_UPDATES.| | * | close | | close | &lt;----------+ * +----------------------+ +----------------------+ */ ReactUpdates.flushBatchedUpdates调用ReactUpdatesFlushTransaction.perform(runBatchedUpdates)方法👇. ReactUpdatesFlushTransaction的实现以及功能12345678910111213141516171819202122232425262728// Wrapper1号定义var NESTED_UPDATES = { initialize: function() { this.dirtyComponentsLength = dirtyComponents.length; }, close: function() { if (this.dirtyComponentsLength !== dirtyComponents.length) { // 处理当 A的update过程中调用了B的setState方法的情况 dirtyComponents.splice(0, this.dirtyComponentsLength); flushBatchedUpdates(); } else { dirtyComponents.length = 0; } },};// Wrapper2号定义var UPDATE_QUEUEING = { initialize: function() { this.callbackQueue.reset(); }, close: function() { this.callbackQueue.notifyAll(); },};ReactUpdatesFlushTransaction.prototype.perform = function (method, scope, a) { // 调用ReactReconcileTransaction去调用runBatchedUpdates方法 return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);} 然后就到了我们执行更新操作的那位选手ReactReconcileTransaction ReactReconcileTransaction的实现以及功能12345678910111213141516171819202122232425262728var SELECTION_RESTORATION = { initialize: ReactInputSelection.getSelectionInformation, close: ReactInputSelection.restoreSelection,};var EVENT_SUPPRESSION = { initialize: function() { var currentlyEnabled = ReactBrowserEventEmitter.isEnabled(); ReactBrowserEventEmitter.setEnabled(false); return currentlyEnabled; }, close: function(previouslyEnabled) { ReactBrowserEventEmitter.setEnabled(previouslyEnabled); },};var ON_DOM_READY_QUEUEING = { initialize: function() { this.reactMountReady.reset(); }, close: function() { this.reactMountReady.notifyAll(); },};var TRANSACTION_WRAPPERS = [ SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING,]; 至此整个事务调用结束 由batchingTransaction -&gt; FlushTransaction -&gt; ReconcileTransaction去调用了ReactUpdates.runBatchedUpdates方法, 然后分别处理了callback, DOM事件等一系列事务调用. 下节预告: React中的事件机制.","link":"/2018/08/06/React源码阅读系列-§2.3-事务机制/"},{"title":"Rust 函数","text":"关键字: Rust 函数 函数是编程语言中对于某些现象或过程的抽象, 函数在 Rust 中扮演着重要的作用, 与 Javascript 相同, 函数在 Rust 中也是作为一等公民的存在, 这也正意味着, Rust 中的函数可以被作为一个数据类型在程序中穿插传递. 定义一个函数在 Rust 中, 无论是在特性中, 还是 impl 块中, 或是在其他地方声明一个函数, 都是使用一样的写法, 和 Javascript 不同(既有函数声明, 也有函数表达式).Rust 中的函数声明: fn name(arg: type) -&gt; returnType { body block } 普通函数123fn add(a: isize, b: isize) -&gt; isize { a + b} 函数做为参数12345fn &lt;T&gt;inner_add(a: T, b: T, add: fn(a: T, b: T) -&gt; T) -&gt; T { add(a, b)}inner_add(1, 2, |a, b| a + b); 函数返回声明一个函数, 并且返回一个返回值, 在大多数语言中都需要用到, return 这个关键字, 但在 Rust 中, 这个关键字可以省略掉, 用更简单的方式返回. 如例子: 123fn add(a: i32, b: i32) -&gt; i32 { a + b // 注意这里没有跟分分号} 或者显式地返回这个语句 123fn add(a: i32, b: i32) -&gt; i32 { return a + b; // 注意这里跟分号} 但是如果在函数块中, 最后一条语句以 ; 结尾, 并没有 return 关键字, 那么编译器便会自动在代码中插入 () 这个特殊的元组作为返回值, 所以如果一个函数没有声明返回值, 都会以一个 () 作为返回, 当然, 这也是可选择的, 若不想要函数返回任何值, 可以将返回值设置成 !, 代表这个函数不返回任何值. return 关键字实际也是很有用的, 比如在一段条件语句中, 提前返回结果 12345678fn ahead_return() -&gt; String { for i in 0..10 { if i == 5 { return \"ahead returned\".to_string(); // 提前返回 } } \"normal returned\".to_string() //直接返回} 返回多个值的函数在 Rust 中, 一个函数的返回, \b 可以没有值, 可以有一个值, 也可以是多个值, 在 Rust 中, 函数要返回多个值, 可以直接采用返回一个元组, 如果函数没有返回值. 123fn tuple_return() -&gt; (i32, i32) { (1, 2)} 返回函数的函数同样, Rust 不止可以传入函数作为参数, 还能够返回一个函数作为返回值. 12345678910type is_one = fn(arg: i32) -&gt; bool;fn returned(arg: i32) -&gt; bool { arg == 1i32}fn caller() -&gt; is_one { returned}println!(\"{:?}\", caller()(1)); // 是不是有一股很熟悉的感觉 \b 作用域与生命周期在介绍闭包之前, 需要先介绍一下 Rust 中的作用域相关的知识. Rust 中所有的作用域都是静态作用域 (Lexical Scope), 通过成对的花括号来创建一个新的作用域 123456789101112fn add(a: i32, b: i32) { // 作用域 1 { // 作用域 2 { // 作用域 3 let s = \"some string\"; } // 作用域 3 退出, s 被释放 println!(\"{:?}\", s); // error[E0425]: cannot find value `s` in this scope }} 闭包 (Closure)在 Rust 中的闭包又叫做一个匿名函数, 但闭包和普通的函数有几点不同 能够捕捉调当前作用域里的变量 编译器能够自动推断输入和返回 在 Rust 中最常用到闭包的地方就是产生子线程, 和迭代器的一些操作:如: 产生一个子线程, 然后计算返回12345678910111213use std::thread;fn main() { let a = String::from(\"Parent string\"); let child = thread::spawn(move || { println!(\"String from parent thread {:?}\", a); // some work here return String::from(\"child thread string\"); }); // some work here let res = child.join(); println!(\"{:?}\", a); // error[E0382]: borrow of moved value: `a` println!(\"{:?}\", res.unwrap());} 这个例子还展示了闭包的 move 关键字, 这个关键字可以把闭包函数体中用到过的变量的所有权转移到闭包内, 这样一来, 闭包外的变量的所有权就被转移了, 因此, 这个变量也不存在于这个作用域中, 它的生命周期就属于当前这个闭包的作用域, 当闭包退出的时候, 那么这个变量也被回收了.或者对\b迭代器做操作123let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];let mapped: Vec&lt;i32&gt; = v.into_iter().map(|val| val + 1 ).collect();println!(\"{:?}\", mapped); // [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; \b这些都是很典型的闭包用例, 同函数一样, 闭包既可以作为参数, 也可以作为返回. \b这些也只是 Rust 语言中函数使用的冰山一角, 函数有非常强大的功能. To be continued …","link":"/2019/03/16/Rust-函数/"},{"title":"Rust 运算符","text":"关键字: Rust 运算符 特性 重载 在 Rust 里, 有很多不一样的操作符, 类似 + - * / 运算符, 每个运算符在不同的应用条件下表达的意思也可能不一样, 而 Rust 中的运算符很特殊, Rust 中的运算符支持重载, 运算符重载这个特性在大部分语言中都没有得到支持, 而 Rust 支持了这一特殊的特性. Rust 中的运算符 运算符 举例 描述 重载方法 ! ident!(…),ident!{…},ident![…] Macro expansion ! !expr Bitwise or logical complement Not != var != expr Nonequality comparison PartialEq % expr % expr Arithmetic remainder Rem %= var %= expr Arithmetic remainder and assignment RemAssign &amp; &amp;expr, &amp;mut expr Borrow &amp; &amp;type, &amp;mut type, &amp;’a type, &amp;’a mut type Borrowed pointer type &amp; expr &amp; expr Bitwise AND BitAnd &amp;= var &amp;= expr Bitwise AND and assignment BitAndAssign &amp;&amp; expr &amp;&amp; expr Logical AND * expr * expr Arithmetic multiplication Mul *= var *= expr Arithmetic multiplication and assignment MulAssign * *expr Dereference * const type, mut type Raw pointer + trait + trait, ‘a + trait Compound type constraint + expr + expr Arithmetic addition Add += var += expr Arithmetic addition and assignment AddAssign , expr, expr Argument and element separator - - expr Arithmetic negation Neg - expr - expr Arithmetic subtraction Sub -= var -= expr Arithmetic subtraction and assignment SubAssign -&gt; fn(…) -&gt; type, |…| -&gt; type Function and closure return type . expr.ident Member access .. .., expr.., ..expr, expr..expr Right-exclusive range literal ..= ..=expr, expr..=expr Right-inclusive range literal .. ..expr Struct literal update syntax .. variant(x, ..), struct_type { x, .. } “And the rest” pattern binding … expr…expr In a pattern: inclusive range pattern / expr / expr Arithmetic division Div /= var /= expr Arithmetic division and assignment DivAssign : pat: type, ident: type Constraints : ident: expr Struct field initializer : ‘a: loop {…} Loop label ; expr; Statement and item terminator ; […; len] Part of fixed-size array syntax &lt;&lt; expr &lt;&lt; expr Left-shift Shl &lt;&lt;= var &lt;&lt;= expr Left-shift and assignment ShlAssign &lt; expr &lt; expr Less than comparison PartialOrd &lt;= expr &lt;= expr Less than or equal to comparison PartialOrd = var = expr, ident = type Assignment/equivalence == expr == expr Equality comparison PartialEq =&gt; pat =&gt; expr Part of match arm syntax &gt; expr &gt; expr Greater than comparison PartialOrd &gt;= expr &gt;= expr Greater than or equal to comparison PartialOrd &gt;&gt; expr &gt;&gt; expr Right-shift Shr &gt;&gt;= var &gt;&gt;= expr Right-shift and assignment ShrAssign @ ident @ pat Pattern binding ^ expr ^ expr Bitwise exclusive OR BitXor ^= var ^= expr Bitwise exclusive OR and assignment BitXorAssign | pat | pat Pattern alternatives | expr | expr Bitwise OR BitOr |= var |= expr Bitwise OR and assignment BitOrAssign || expr || expr Logical OR ? expr? Error propagation 这些可重载的操作符的特性都在 std::ops 这个包中被导出. 一元运算符 (Unary Operator)当运算符作为一元运算符时, 没有重载的操作. * &amp; 这一对运算符作为一元运算符的时候是一对作用相反的运算符. &amp; 运算符用于取引用, 也就是 Rust 中的 Borrow 概念, 可以大致理解为 C/C++ 中的取址操作; * 运算符用于解引用. - 运算符用于取负数, 用于 integer/float 类型. ! 位取反运算符, 将运算对象按位取反 如 !b0000_0001 结果为 b1111_1110; 二元运算符 (Binary Operator)算数运算符+ - * / % 和其它语言中的算数运算符一模一样, 用于算术运算 位运算&amp; | ^ &lt;&lt; &gt;&gt; 位运算符也几乎和 C/C++ 语言中的位运算符一样. 比较运算符&gt; &gt;= == != &lt;= &lt; 这些运算符用于值的比较, 要注意的地方是比较运算也必须要发生在同一种类型的值之间, 如 8i32 &lt; 9i64 这样的比较是会被编译器抛错的. 比较运算符会产生一个 bool 类型的值 断言运算符&amp;&amp; || 作为逻辑短路断言运算符, 和其它语言中的作用是一样的, 但是 expr &amp;&amp; expr 中的 expr 必须是 bool 类型, 这点是和其它语言不一样的地方. 运算符重载运算符重载实际上通常只是一种 语法糖. 它可以简单地通过函数调用来模拟如1a + b * c // a b c 均不是数值类型 但却支持用运算符 模拟1add(a, multiply(b, c)) // 假设乘法优先级是高于加法的 假设我们需要去实现加法的重载, 我们就必须要用到 Add 这个特性, Add 这个 特性的签名是:1234567// 这里的 RHS 泛型 默认值是 Self 也就是当前实现这个特性的类型// 同样, 你也可以指定这个地方的 RHS 为别的类型pub trait Add&lt;RHS = Self&gt; { type Output; // 这个类型是用来定义返回值的 [must_use] fn add(self, rhs: RHS) -&gt; Self::Output; // 实现 Add 特性必须要实现 add 这个方法} \b在 Rust 中的重载实际很简单, 如我们要实现加法运算的重载就可以这样:123456789101112131415161718use std::ops::Add; // 载入 Add 特性#[derive(Debug, Clone, Copy)]struct Foo { a: u32, b: u32,}impl Add for Foo { type Output = Foo; fn add(self, rhs: Foo) -&gt; Foo { // rhs = right hand side println!(\"Add 运算符重载!\"); return Foo { a: self.a + rhs.a, b: self.b + rhs.b } }} 这些就是 Rust 中的运算符, 运算符有非常多, 需要花时间去记忆, 有很多不常用但非常好用的运算符, 需要靠在实践中多使用, 慢慢会熟悉起来. To be continued …","link":"/2019/03/13/Rust-运算符/"},{"title":"Rust 控制流","text":"关键字: Rust 控制流 代码跑与不跑, 跑了之后的结果是什么, 都依赖于控制流, Rust 中的控制流分为两大类 判断 循环 判断表达式if在 Rust 中, if 从句不是一个声明语句, 是一个表达式, 与 Java/Javascript 中的 if 不同:Rust 中:123456let number = 10;let a = if number &lt; 10 { 20} else { 1} Javascript 中:1234567let number = 10;let a;if (number &lt; 10) { a = 20;} else { a = 1;} if letif 从句还有一个特殊的分支 就是 if let, 实际上这个写法是对接下来要讲的 match 的一个简写1234567let a = Some(\"b\");// 这里实际上是一个匹配的解构, 在下面会说到let c = if let Some(val) = a { \"equal\" // 不能有分号, 因为是返回值} else { \"not equal\"} 1. Rust 中的 if 是表达式而不是声明语句2. Rust 中的 if 后接续的条件只能是 bool 类型, 而不能像 Javascript 一样任意类型的值都可以. matchmatch 表达式在 Rust 中就像 Javascript 中的 switch 声明一样, 但功能远比 switch 的功能强大123456789101112131415161718enum Coin { Penny, Nickel, Dime, Quarter,}let coin = Coin::Quater;let money = match coin { Coin::Penny =&gt; { println!(\"Lucky penny!\"); 1 }, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25,} 其中最常用的用法就是配合 Enum 类型, 带有数据的枚举类通过匹配能够拿到携带的数据, 来提供使用. 循环体Rust 一共提供了三种循环的方式: loop while for loop在 Rust 中, 最常见的循环方式就是 loop 语句, 通过 loop 语句产生循环, 然后在循环体中通过 break, continue, return, 这些关键字来控制循环流, 最后达到目的. 不出意外地, loop 依然还是一个表达式, 并且是能够返回值的 _(:зゝ∠)_. 最简单的循环 123loop { println!(\"无限循环\");} 中断的循环 12345678let mut sum = 0;let final_sum = loop { if sum &gt; 10 { break sum // break 这段循环 并返回 sum } sum += 1;};println!(\"{:?}\", final_sum); while和 loop 相比, 另外一个用得比较多的循环语句就是 while, while 比较起 loop 来, 明显的区别就是, while 循环的条件语句外置并且 while 语句没有返回值(或者说返回值是一个空元组()), 当循环条件不满足, 循环就直接结束. 和 loop 一样效果的循环1234while true { println!(\"我和 loop 一样耶\"); // 可以在循环体中插入 break return 语句作为中断} \b条件循环1234let mut counter = 0;while counter &lt; 10 { counter += 1;} forfor 循环相对来说比较特殊, 只能用在那些实现过 iterator 特性的对象上, \b没有实现这个特性的对象是没有办法用 for 语句表达的, for 语句是声明, 而不是表达式, 所以也是没办法使用break value 的.123for item in 1..11 { // from..to 产出一个区间为 [from, to) Range 类型的对象, 实现了 iterator println!(\"{:?}\", item);} 以上就是 Rust 中的控制流, 每一个都提供了非常强大的功能, 实际应用中根据不同的场景应用, 来达到不同的目的.","link":"/2019/03/12/Rust的控制流/"},{"title":"react 16 逆向系列","text":"关键字: React Fiber Hooks react 16.x 逆向工程上一部逆向的坑还没填完, 又开下一个坑, -&gt;_-&gt; 这次来逆向一下 16.x 版本的 React,在这个目录文写出来的时候, React 在线上的正式版本是 16.8.10, 希望到这个系列写完之前, React 都不会发布 17.0 beta 版本. 实际上 React 16.x 版本的源码相较于 15.x 时期, 不论代码组织, 还是代码质量上又更上了一层楼, 更引进了很多新的东西 lazy, memo, contextType Hooks 本版本除 Fiber 以外最重大的 feature (个人角度) Profiler, Suspense Brand new Context 0b0001 从分片调度来看 React 的调度机制0b0010 React Fiber 调度器的实现 (施工中🚧 …)后续目录待补全","link":"/2019/03/28/react-16/"},{"title":"React源码阅读系列-§2.1-生命周期过程详解","text":"关键字: 生命周期 钩子函数 在§1.1节大概的了解了React的生命周期以及在各个阶段的生命周期钩子函数的调用. 在本节主要详细讲解各个生命周期函数, 以及一些对性能上能够产生优化的细节. 以下面内容仅适用于用户自定义组件, 无状态组件不经历大部分钩子函数的调用. \b生命周期的阶段每一个React的组件都会经历它的生命周期. 1. 挂载阶段 (Mounting Period) 1) 组件被实例化 在之前的§1.3节讲到每一个CustomComponent都是被CompositeComponentWrapper给包裹了起来, 实际被实例化的地方是在ReactCompositeComponent._constructComponentWithoutOwner方法中. 1return new CustomComponent(publicProps, publicContext, updateQueue); 此处就是所有的组件的构造函数被调用的地方. 为的是把实例存在ReactInstanceMap中, 方便使用, 例如React.findDOMNode()方法就通过这个ReactInstanceMap拿到了实例通过实例在对应的ReactDOMTree中找到了对应的DOM节点. 2) componentWillMount的调用 无状态组件是不经历这一步的, 如果用户有添加componentWillMount这个方法, 那么该方法将会在performInitialMount方法内被调用. 3) render的调用时机 render被调用有两种情况. 第一种情况是如果组件本身是无状态组件那么在 123456789101112var renderedElement;// 如果是无状态的组件返回false, 否则返回true.var doConstruct = shouldConstruct(Component);var inst = this._constructComponent( doConstruct, // false publicProps, publicContext, updateQueue, );if (!doConstruct &amp;&amp; (inst == null || inst.render == null)) { renderedElement = inst; } 方法内部这个组件的render方法就可以看做已经被调用过了, 因为本身就只是一个函数类型的组件. 第二种是如果并非无状态组件, 那么render的调用发生在performInitialMount方法中1234// 在不满足上面的条件时, renderedElement自然为undefined.if (renderedElement === undefined) { renderedElement = this._renderValidatedComponent(); // 此处调用inst.render()} 这里的renderedElement就是在第§1.2节通过render()方法返回出来的React.createElement()的结构. 是一个ReactElement的类实例. 然后会被用来通过进行一个递归调用, 所有的自定义组件都会被转换到ReactDOMComponent, 然后通过ReactDOMComponent.mountComponent方法返回一段ReactNode的对象实例 最后调用render方法之后得到的markup类似于: 从ReactCompositeComponent到ReactDOMComponent, 然后再被转换成为真实的DOM节点(划重点: DOM节点内只有字符串). \b在ReactDOMComponent当中有一个比较重要的方法: 123456789101112131415161718192021222324252627this._createInitialChildren = function(transaction, props, context, lazyTree) { var innerHTML = props.dangerouslySetInnerHTML; if (innerHTML != null) { if (innerHTML.__html != null) { DOMLazyTree.queueHTML(lazyTree, innerHTML.__html); } } else { var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null; var childrenToUse = contentToUse != null ? null : props.children; if (contentToUse != null) { if (contentToUse !== '') { DOMLazyTree.queueText(lazyTree, contentToUse); } } else if (childrenToUse != null) { var mountImages = this.mountChildren( childrenToUse, transaction, context, ); for (var i = 0; i &lt; mountImages.length; i++) { DOMLazyTree.queueChild(lazyTree, mountImages[i]); } } }} 简单的解释一下这段方法: 首先先去判断了是否有强行塞入innerHTML的这种做法, 很显然官方本身是不推荐用户这样去使用, 但是在某一些的特定场景下, 必须要用到这种方法. true, 就把__html作为当前节点的innerHTML. false, 继续进行下一步. \b接着去判断当前的children是否是CONTENT_TYPES这个枚举类的成员. true, 那就把children塞给当前的节点作为innerHTML. false, 那么就证明现在的这个children并非是一个DOM节点而是一个自定义的组件. \b那就继续调用instantiateReactComponent方法来实例化children直到所有的子节点被创建完成.注意: 此处是一个递归调用的过程 到这个地方, 基本render方法的调用就结束了, 调用完成的结果就是上面图例的markup对象. 4) componentDidMount的调用: 123if (inst.componentDidMount) { transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);} 在这里React的开发者们很聪明的采用了一个队列的形式, 采用批处理的方式来调用componentDidMount的方法.到这个地方, React的挂载阶段基本就已经结束了. 对于事务处理以及事件机制还有对象池的概念, 到后面会再说到. 2. 存在阶段 \b存在阶段主要对应的主要是对浏览器事件的一个响应, 因为用户操作而触发的一系列浏览器事件. \b接下来的更新都是交互后产生的更新操作, \b浏览器响应相应的事件最后被setState或改变props触发更新. (setState会在后面章节进行详细的介绍). 主播再不更新我就退订! updateComponent (这里以ReactCompositeComponent [自定义组件]为例) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576var updateComponent = function( transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext, ) { var inst = this._instance; invariant( // 如果对已经被卸载掉的节点调用这个方法则抛异常 inst != null, 'Attempted to update component `%s` that has already been unmounted ' + '(or failed to mount).', this.getName() || 'ReactCompositeComponent', ); var willReceive = false; var nextContext; // 检查context上的值是否一致 if (this._context === nextUnmaskedContext) { nextContext = inst.context; } else { nextContext = this._processContext(nextUnmaskedContext); willReceive = true; } var prevProps = prevParentElement.props; var nextProps = nextParentElement.props; // 对比前后的Element是否相同 if (prevParentElement !== nextParentElement) { // 更新标识符设置为true willReceive = true; } if (willReceive &amp;&amp; inst.componentWillReceiveProps) { inst.componentWillReceiveProps(nextProps, nextContext); } var nextState = this._processPendingState(nextProps, nextContext); // 拿到下一个时间的state var shouldUpdate = true; if (!this._pendingForceUpdate) { if (inst.shouldComponentUpdate) { shouldUpdate = inst.shouldComponentUpdate(// &lt;- 实例shouldComponentUpdate钩子调用 nextProps, nextState, nextContext, ); } else { // 处理一个PureComponent的条件, 关于PureComponent与Component的对比 // 可以在给到的几个链接里多看看这里就不多做解释 // https://60devs.com/pure-component-in-react.html // https://stackoverflow.com/questions/41340697/react-component-vs-react-purecomponent if (this._compositeType === CompositeTypes.PureClass) { shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState); } } } this._updateBatchNumber = null; // 从这里可以看到shouldUpdate这个值默认都是被设置为true的, 所以在性能优化的时候, 可以考虑使用 // shouldComponentUpdate这个钩子函数来控制一下重绘的组件的数量来达到减少重绘调用优化性能的目的 if (shouldUpdate) { this._pendingForceUpdate = false; // 传递新的属性, 状态, 上下文进行更新 this._performComponentUpdate( nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext, ); } else { this._currentElement = nextParentElement; this._context = nextUnmaskedContext; inst.props = nextProps; inst.state = nextState; inst.context = nextContext; } } 在判断完需要更新这个结果之后, 就要进行接下来的performUpdate操作. 开始你的表演 performUpdate performUpdate顾名思义就是要进行实际的更新操作了, 更新操作实际上大致与初始的挂载操作一致. 代码走你! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748_performComponentUpdate: function( nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext,) { var inst = this._instance; var hasComponentDidUpdate = Boolean(inst.componentDidUpdate); var prevProps; var prevState; var prevContext; if (hasComponentDidUpdate) { prevProps = inst.props; prevState = inst.state; prevContext = inst.context; } if (inst.componentWillUpdate) { // 👇 willUpdate 钩子函数调用 inst.componentWillUpdate(nextProps, nextState, nextContext); } this._currentElement = nextElement; this._context = unmaskedContext; inst.props = nextProps; inst.state = nextState; inst.context = nextContext; // 把更新传递到DOM上去 这边的更新跟挂载时的操作很相似 所以就不做展开了. this._updateRenderedComponent(transaction, unmaskedContext); if (hasComponentDidUpdate) { // 设置好最后一个更新的钩子函数, 在事务操作结束之后调用 transaction .getReactMountReady() .enqueue( inst.componentDidUpdate.bind( inst, prevProps, prevState, prevContext, ), inst, ); }} 至于在最后, 怎么把这些节点给反映到到DOM上去的呢? 请看下回分解. 下节预告: 从虚拟DOM到真实的DOM.","link":"/2018/07/26/React源码阅读系列-§2.1-生命周期过程详解/"},{"title":"Rust 的类型系统","text":"关键字: Rust 类型系统 Rust 的类型系统Rust 是一门静态编译类的语言, 类型系统的设计可以帮助编译器在编译期内就将”容易出错的代码”暴露给编写程序的人. Rust 的类型系统的设计目标是: 安全性 效率 简洁 Rust 的编译器也会根据程序编写者编写的代码自动推断变量的类型, 正因如此, Rust 的程序\b可以变得更加干净. 当然, 并不能过分依靠这个推断系统, 因为该报错的地方, 编译器依旧会毫不留情地报错. 关于自动推断类型可以看这个例子:12345678910// 代码摘抄自 Programming Rust 一书fn build_vector() -&gt; Vec&lt;i16&gt; { //&lt;-- 注意返回值// let mut v: Vec&lt;i16&gt; = Vec::&lt;i16&gt;::new(); let mut v = Vec::new();// v.push(10i16);// v.push(20i16); v.push(10); v.push(20); v} 上面这个例子, 由于函数的返回是 v, 而返回值的类型是 Vec&lt;i16&gt;, 那么自然 v 会被推断为 Vec&lt;i16&gt; 类型. 所以 v.push(item), item 的类型自然是 i16. 比较注释处的代码会显得更加简洁. Rust 的类型种类基础类型 内存大小 (bits) 无符号整数 有符号整数 浮点数 8 u8 i8 - 16 u16 i16 - 32 u32 i32 f32 64 u64 i64 f64 机器字长 usize isize - 注: 机器字长根据 OS 支持的位数来自适应的, 如果你的代码跑在 32 bit 的机器上, 那么机器字长就应该为 32bit, 对应的 uszie 就是 32 位, 但是要注意即使在 32 位的电脑上, 内存里的 usize 和 u32 的内存表示是一样的, 但 usize != u32, 在执行特定操作时, 需要将 usize 通过 usize as u32 强转成 u32 类型. 无符号整数每一位都用来表示它的大小. 范围从 0 - 2size-1. 符号整数在 Rust 中用 2 的补码来表示, 因此也没有 ±0 的问题存在. 能够表示的范围为 [2size - 1, 2 size - 1 -1] 浮点数在 Rust 中的表示遵循了 IEEE 754-2008 的单精度和双精度浮点数标准. 字符类型在 Rust 中表示单个有效的 Unicode 字符, 长度为 32-bit, char 只能用来表示一个单独的 Unicode 字符, 以 '\b独' 形式, 与 str 类型不同在于, char 表示的字符要用 单引号 (') 来修饰, 而 str 类型使用双引号(&quot;)修饰, 也可以使用 '\\u{007F}' 的方式来表示一个 char 类型. 布尔类型在 Rust 中用 true 和 false 表示, 在内存中表示为一个完整的字节 (8-bit), 所以你可以创建一个指向改地址的指针. 最大的数Rust 中算数运算如果发生了位溢出会致使整个程序崩溃, Rust 能够表示的最大的有符号整数可以在标准库对应的类型下成员std::itype::MAX 如 std::i32::MAX. Byte 类型对于很多语言中存在的 byte 类型, 在 Rust 中用 u8 来表示, 当从 socket 和 文件中读取数据时, 都会产出 u8 类型的值. 整数类型的字面量表示12345let suffix = 245u8;let underscore = 222_222u32;let bytes_literal = 0b1111_1111; // u8let float = 0.5; // 自动推断为f64.let octal = 0o53; Rust 还提供了一种方式能够方便的将 ASCII 转换成 u8 类型的写法let ascii = b'ASCII';, 这样可以方便快捷地把 ASCII Code 转换成一连串的二进制数. 类型转换Rust 也像 Go, Java 这样的语言一样, 提供了类型之间的转换的方法, 不过关于 Rust 中的类型转换, 此处不做重点介绍, 会专门留一小节来做重点介绍. 但是要注意的是, 与 C, C++ 等语言不同的地方是, Rust 不会对值操作时进行隐式转换, 如类型为 i32 和 i64 的两个变量进行比较时, 尽管 i32 的值永远都是一个有效的 i64 的值, 但因为类型不同, 编译器会在编译期就抛错. 数组类型数组在 Rust 中的表示为 [T;N], 代表一个含有 N 个 T 类型的集合, 在 Rust 中数组是一个固定大小的一个类型, 它在编译期就可以判定所需要内存空间的大小: N * size(T). 数组不能够添加和删除成员, 但可以改变成员. 数组成员被保存在栈内存中.12let a = [20u8;40]; // 拥有 40 个 值为 20 的数组a.push(20u8); // no method named `push` found for type `[u8; 40]` in the current scope 动态数组类型动态数组类型是根数组有着同样作用但内存是在运行时动态分配的, 并且可以动态添加, 删除成员数组, 更改数组的容量大小. \b动态数组的成员被保存在堆内存中. 切片类型切片类型是对数组或者动态数组的一个引用, 内存中表现为一个胖指针 (Fat Pointer), 这个胖指针组成如表:字段名 | 描述———-|————pointer | 指向切片第一个元素的指针number | 该切片拥有多少个元素 数组, 动态数组, 切片的内存模型比较 图片来自于 Programming Rust 一书 字符串字符串可以被视为一连串的 char 类型的组合, 字符串有两种类型 str (不可变, 可通过索引访问) String (可变, 不可通过索引访问) String在内存中的表示123let noodles = \"noodles\".to_string();let oodles = &amp;noodles[1..];let poodles = \" _ \"; % asset_img 字符串内存模型.jpg 字符串内存模型 %} 以上来自 Programming Rust 一书 String 在内存中是通过运行时动态分配在堆内存上的, 但 String 在堆内存上还是需要有对应的表示的, 实际上, String 类型在堆内存上的表示: 字段名 描述 ptr 指向堆内存上的第一个字符的内存地址 capacity 当前 String 的容量 length 当前 String 的长度 在 Rust 中, 字符串字面量如: “I am some string” 的类型为 &amp;str, 并且这个变量的生命周期和程序一样长, 当程序启动时该字符串字面量就被创建在常量池中, 当程序结束了之后, 常量池里的该变量也对应销毁. \b而动态的 String 用来保存一些动态数据的生命周期并不跟字符串字面量一样长, 这些内存被动态分配. 指针类型Rust 和 C/C++ 一样, 拥有指针类型, 不过 Rust 的指针类型分为引用指针和裸指针. 引用指针通过 &amp; 操作符就可以创建一个指针, 指向对应的变量.123let a = 20u32;let ptr = &amp;a;println!(\"{:p}\", ptr); // 0x7fff304b5774 但是, 虽然这样就可以直接创建指针, 但是要上例的指针指向的是栈中的变量而不是堆中的变量, 很多时候由于栈的空间有限制, 会倾向于选择在堆上创建变量并建立指针指向这个变量, 如动态数组, 字符串中便有一个保存当前指针的字段. 盒类型通过 Rust 标准库中提供的 Box 类型, 可以非常方便地在堆内存中创建一个变量, 类型为 Box&lt;T&gt;.1let heap = Box::new(20u32); // Boxed value, 这样就在堆上创建了一个 u32 类型的变量 裸指针Rust 中的裸指针就和 C/C++ 中的指针类型一样, 拥有同样的功能. 张翁因如此, 野指针由于不可控, 也可能出现空指针的问题. 复合类型元组元组在 Rust 中的作用和表现跟其他语言如: Python 中一样, 表示一个有序的”数组”, 和数组不一样, 元组的每一个元素可以拥有不同的类型.123let tuple = (1u32, 2u32, 3u32);println!(\"{:?}\", tuple.0); // 用 tuple.index 方式来访问成员let (a, b, c) = tuple; // tuple 类的解构 在内存中表现为一段连续的不同类型内存的组合, 可以通过元素的位置来访问.并且 tuple 可以通过解构来取得里面的元素. 结构体结构体 (Struct) 跟其他 OOP 中的 class 有些相似, 用来描述一系列类型的组合, 把这些类型聚合在一起, 便成了一个结构体.结构体可以大致划分为两种, 一种就是最普通的结构体, 一种是元组类结构体123456struct Point { x: u32, y: u32};struct IPv4(u8, u8, u8, u8); 枚举Rust 中的枚举类和 C 中的枚举类很相似, 并且有更加强大的功能, Rust 的枚举成员能够包含需要的信息, 并且还可以在枚举类上实现方法.","link":"/2019/03/10/Rust的类型系统/"}],"tags":[{"name":"react16.x 源码逆向","slug":"react16-x-源码逆向","link":"/tags/react16-x-源码逆向/"},{"name":"React源码阅读","slug":"React源码阅读","link":"/tags/React源码阅读/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"}],"categories":[{"name":"React16逆向系列","slug":"React16逆向系列","link":"/categories/React16逆向系列/"},{"name":"React源码阅读系列","slug":"React源码阅读系列","link":"/categories/React源码阅读系列/"},{"name":"Rust lang","slug":"Rust-lang","link":"/categories/Rust-lang/"}]}