<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeremy&#39;s Note</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jeremywu.info/"/>
  <updated>2018-07-26T15:43:02.000Z</updated>
  <id>https://jeremywu.info/</id>
  
  <author>
    <name>Jeremy Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React源码阅读系列-§2.1-生命周期过程详解</title>
    <link href="https://jeremywu.info/2018/07/26/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A72.1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jeremywu.info/2018/07/26/React源码阅读系列-§2.1-生命周期过程详解/</id>
    <published>2018-07-26T13:18:31.000Z</published>
    <updated>2018-07-26T15:43:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: </strong> <code>生命周期</code> <code>钩子函数</code></p><p>在<a href="/2018/07/17/React源码阅读系列-§1.1-生命周期-Lifecycle">§1.1节</a>大概的了解了React的生命周期以及在各个阶段的生命周期钩子函数的调用.</p><p>在本节主要详细讲解各个生命周期函数, 以及一些对性能上能够产生优化的细节.</p><a id="more"></a><div class="tip"><br>以下面内容仅适用于用户自定义组件, 无状态组件不经历大部分钩子函数的调用.<br></div><hr><h3 id="生命周期的阶段"><a href="#生命周期的阶段" class="headerlink" title="生命周期的阶段"></a>生命周期的阶段</h3><p><strong>每一个</strong>React的组件都会经历它的生命周期.</p><h4 id="1-挂载阶段-Mounting-Period"><a href="#1-挂载阶段-Mounting-Period" class="headerlink" title="1. 挂载阶段 (Mounting Period)"></a>1. 挂载阶段 (Mounting Period)</h4><ul><li><p>1) 组件被实例化</p><p>在之前的<a href="/2018/07/21/React源码阅读系列-§1.4-来人-给我new一下">§1.3节</a>讲到每一个<code>CustomComponent</code>都是被<code>CompositeComponentWrapper</code>给包裹了起来, 实际被实例化的地方是在<code>ReactCompositeComponent._constructComponentWithoutOwner</code>方法中.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CustomComponent(publicProps, publicContext, updateQueue);</span><br></pre></td></tr></table></figure><p>此处就是所有的组件的构造函数被调用的地方. 为的是把实例存在<code>ReactInstanceMap</code>中, 方便使用, 例如<code>React.findDOMNode()</code>方法就通过这个<code>ReactInstanceMap</code>拿到了实例通过实例在对应的<code>ReactDOMTree</code>中找到了对应的DOM节点.</p></li><li><p>2) componentWillMount的调用</p><p>无状态组件是不经历这一步的, 如果用户有添加<code>componentWillMount</code>这个方法, 那么该方法将会在<code>performInitialMount</code>方法内被调用.</p></li><li><p>3) render的调用时机</p><p>render被调用有两种情况. </p><ol><li><p>第一种情况是如果组件本身是无状态组件那么在</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> renderedElement;</span><br><span class="line"><span class="comment">// 如果是无状态的组件返回false, 否则返回true.</span></span><br><span class="line"><span class="keyword">var</span> doConstruct = shouldConstruct(Component);</span><br><span class="line"><span class="keyword">var</span> inst = <span class="keyword">this</span>._constructComponent(</span><br><span class="line">    doConstruct, <span class="comment">// false</span></span><br><span class="line">    publicProps,</span><br><span class="line">    publicContext,</span><br><span class="line">    updateQueue,</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">if</span> (!doConstruct &amp;&amp; (inst == <span class="literal">null</span> || inst.render == <span class="literal">null</span>)) &#123;</span><br><span class="line">  renderedElement = inst; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法内部这个组件的<code>render</code>方法就可以看做已经被调用过了, 因为本身就只是一个函数类型的组件.</p></li><li>第二种是如果并非无状态组件, 那么<code>render</code>的调用发生在<code>performInitialMount</code>方法中<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在不满足上面的条件时, renderedElement自然为undefined.</span></span><br><span class="line"><span class="keyword">if</span> (renderedElement === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    renderedElement = <span class="keyword">this</span>._renderValidatedComponent(); <span class="comment">// 此处调用inst.render()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里的renderedElement就是在第<a href="/2018/07/18/React源码阅读系列-§1.2先有节点后有天%20ReactCreateElement">§1.2节</a>通过<code>.render()</code>方法返回出来的<code>React.createElement()</code>的结构. 是一个<code>ReactElement</code>的类实例. 然后会被用来通过进行一个递归调用, 所有的自定义组件都会被转换到<code>ReactDOMComponent</code>, 然后通过<code>ReactDOMComponent.mountComponent</code>方法返回一段<code>ReactNode</code>的对象实例</p><p>最后调用render方法之后得到的markup类似于:</p><img src="/2018/07/26/React源码阅读系列-§2.1-生命周期过程详解/markup.png" title="markup"></li></ul><h3 id="…未完待续"><a href="#…未完待续" class="headerlink" title="…未完待续"></a>…未完待续</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;/strong&gt; &lt;code&gt;生命周期&lt;/code&gt; &lt;code&gt;钩子函数&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;/2018/07/17/React源码阅读系列-§1.1-生命周期-Lifecycle&quot;&gt;§1.1节&lt;/a&gt;大概的了解了React的生命周期以及在各个阶段的生命周期钩子函数的调用.&lt;/p&gt;
&lt;p&gt;在本节主要详细讲解各个生命周期函数, 以及一些对性能上能够产生优化的细节.&lt;/p&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>React源码阅读系列-§1.5-ReactDOM.render干了啥</title>
    <link href="https://jeremywu.info/2018/07/22/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A71.5-ReactDOM-render%E5%B9%B2%E4%BA%86%E5%95%A5/"/>
    <id>https://jeremywu.info/2018/07/22/React源码阅读系列-§1.5-ReactDOM-render干了啥/</id>
    <published>2018-07-22T14:01:06.000Z</published>
    <updated>2018-07-26T13:13:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: </strong> <code>ReactDOM.render</code> <code>调用栈</code></p><p>React应用的启动可谓是相当简单了, 无需过多的配置, 只需要三行代码便可以启动</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line">render((<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>启动!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>), <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>));</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>ReactDOM.render</code>方法一共接受三个参数:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render = <span class="function"><span class="keyword">function</span>(<span class="params">nextElement, container, callback</span>) </span>&#123;...&#125;;</span><br></pre></td></tr></table></figure></p><p>第一个参数为需要渲染的<code>ReactElement</code>;<br>第二个参数是用来挂载渲染好的DOM节点的<code>Container</code>;<br>第三个参数为一个可选参数,用来接受一个在该方法结束之后被调用的一个<code>Function</code>;</p><p>结合上一些代码来了解一下, 该方法被调用时到底经过了哪一些过程.</p><hr><h3 id="ReactDOM-render-的调用栈"><a href="#ReactDOM-render-的调用栈" class="headerlink" title="ReactDOM.render()的调用栈"></a><code>ReactDOM.render()的调用栈</code></h3><p>为了更好的能够理解这一章的内容, 上一篇已经通过了<code>ReactCompositeComponent</code>做了一轮铺垫, 在有了上一篇的知识的基础上, 本篇内容的复杂度将会大大降低.</p><div class="tip"><br>所有内容均建立在没有启动<code>ServerSideRendering</code>的情况之下.<br></div><h4 id="通过文字来描述"><a href="#通过文字来描述" class="headerlink" title="通过文字来描述:"></a>通过文字来描述:</h4><ol><li><code>render</code>方法首先会调用<code>_renderSubtreeIntoContainer</code>来启动调用过程, 该方法会调用<code>_renderNewRootComponent</code>方法. 并且会调用<code>render</code>传入的callback方法.</li><li><code>_renderNewRootComponent</code>会调用<code>instantiateReactComponent()</code>方法来实例化被传入的组件. 然后得到对应的组件树.</li><li>把得到的组件树通过<code>ReactUpdates.batchedUpdates</code>更新到DOM中.<br>i. <code>ReactUpdates.batchedUpdates</code>会通过调用<code>batchingStrategy.batchedUpdates</code>来调用<code>batchedMountComponentIntoNode</code>方法. 这里有关于<strong><u>ReactTransaction</u></strong>的概念, 在后面一章里面会讲到.<br>ii. 这边需要关注的方法就是<code>batchedMountComponentIntoNode</code>方法.</li><li><code>batchedMountComponentIntoNode</code>调用<code>mountComponentIntoNode</code>, 然后紧接着<code>ReactReconciler.mountComponen</code>被调用. 到这里开始就是上一章讲过的那一部分内容了. 实例内部的生命周期被调用, 然后返回了对应的DOM结构.</li><li>返回的DOM结构被通过<code>ReactMount._mountImageIntoNode</code>方法挂载进入真正的DOM中.</li><li>至此, 整个调用过程结束.</li></ol><h4 id="通过一张流程图来描述"><a href="#通过一张流程图来描述" class="headerlink" title="通过一张流程图来描述:"></a>通过一张流程图来描述:</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">↓: 表示调用</span><br><span class="line"><span class="code">            开始</span></span><br><span class="line"><span class="code">             ↓</span></span><br><span class="line">   ReactMount.render</span><br><span class="line"><span class="code">             ↓</span></span><br><span class="line">ReactMount._renderSubtreeIntoContainer</span><br><span class="line"><span class="code">             ↓</span></span><br><span class="line">ReactMount._renderNewRootComponent // 触发创建真实DOM节点</span><br><span class="line"><span class="code">             ↓</span></span><br><span class="line">instantiateReactComponent  // 创建真实DOM</span><br><span class="line"><span class="code">             ↓</span></span><br><span class="line">batchedMountComponentIntoNode</span><br><span class="line"><span class="code">             ↓</span></span><br><span class="line">mountComponentIntoNode</span><br><span class="line"><span class="code">             ↓ </span></span><br><span class="line">ReactReconciler.mountComponent</span><br><span class="line"><span class="code">             ↓</span></span><br><span class="line">ReactCompositeComponent.mountComponent</span><br><span class="line"><span class="code">             ↓</span></span><br><span class="line">ReactCompositeComponent.performInitialMount</span><br><span class="line"><span class="code">             ↓</span></span><br><span class="line">ReactMount._mountImageIntoNode     </span><br><span class="line"><span class="code">             ↓\</span></span><br><span class="line"><span class="code">        setInnerHTML |----  通过根节点挂载</span></span><br><span class="line"><span class="code">             ↓/</span></span><br><span class="line">ReactDOMComponentTree.precacheNode    // 保存virtualDOM </span><br><span class="line"><span class="code">             ↓</span></span><br><span class="line"><span class="code">            结束</span></span><br></pre></td></tr></table></figure><h4 id="通过一张关系图来描述"><a href="#通过一张关系图来描述" class="headerlink" title="通过一张关系图来描述"></a>通过一张关系图来描述</h4><img src="/2018/07/22/React源码阅读系列-§1.5-ReactDOM-render干了啥/render.png" title="render"><hr><h3 id="小结-amp-预告"><a href="#小结-amp-预告" class="headerlink" title="小结&amp;预告:"></a>小结&amp;预告:</h3><p>通过了解框架中封装的方法内部的调用实现, 可以更直观的去了解框架, 能够在后续的工作当中让自己写出来性能更加高的代码, 并且对整体应用能有所规划. </p><p><strong>下期预告: React生命周期的具体分析.</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;/strong&gt; &lt;code&gt;ReactDOM.render&lt;/code&gt; &lt;code&gt;调用栈&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;React应用的启动可谓是相当简单了, 无需过多的配置, 只需要三行代码便可以启动&lt;/p&gt;
&lt;figure class=&quot;highlight jsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; React &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123;render&amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react-dom&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;render((&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;启动!&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;), &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.querySelector(&lt;span class=&quot;string&quot;&gt;&#39;#root&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>React源码阅读系列-§1.4-来人, 给我new一下</title>
    <link href="https://jeremywu.info/2018/07/21/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A71.4-%E6%9D%A5%E4%BA%BA-%E7%BB%99%E6%88%91new%E4%B8%80%E4%B8%8B/"/>
    <id>https://jeremywu.info/2018/07/21/React源码阅读系列-§1.4-来人-给我new一下/</id>
    <published>2018-07-21T13:22:56.000Z</published>
    <updated>2018-07-26T13:44:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: </strong> <code>ReactCompositeComponent</code> <code>instantiate</code></p><h3 id="让我们先实例化一个组件"><a href="#让我们先实例化一个组件" class="headerlink" title="让我们先实例化一个组件"></a>让我们先实例化一个组件</h3><p><a href="/2018/07/20/React源码阅读系列-§1.3先给我整一个Component/">上一章</a>讲到了, React的<code>Component</code>种类, 但没讲到用户自己写的<code>CustomComponent</code>是怎么被实例化的. 在后面的章节会介绍到关于应用启动的过程到底发生了哪些事情, 在这边就先简单的做一个铺垫. 主要关注在<code>CustomComponent</code>的实例化过程.</p><a id="more"></a><p>当我们调用<code>React.render(...)</code>方法的时候, 会调用<a href="https://github.com/facebook/react/blob/v15.6.2/src/renderers/shared/stack/reconciler/instantiateReactComponent.js" target="_blank" rel="noopener">ReactMount.js</a>中的<code>instantiateReactComponent</code>方法, 该方法中涉及到实例化一个<code>CustomComponent</code>的代码为:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">node, shouldHaveDebugID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line">  <span class="keyword">var</span> element = node;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> element.type === <span class="string">'string'</span>) &#123;</span><br><span class="line">        instance = ReactHostComponent.createInternalComponent(element);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInternalComponentType(element.type)) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> element.type(element);</span><br><span class="line">        <span class="keyword">if</span> (!instance.getHostNode) &#123;</span><br><span class="line">          instance.getHostNode = instance.getNativeNode;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> ReactCompositeComponentWrapper(element);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">'string'</span> || <span class="keyword">typeof</span> node === <span class="string">'number'</span>) &#123;</span><br><span class="line">        instance = ReactHostComponent.createInstanceForText(node);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Encountered invalid React node of type "</span> + <span class="keyword">typeof</span> node );</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>关键的一行代码在此处:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> ReactCompositeComponentWrapper(element);</span><br></pre></td></tr></table></figure></p><p>关键角色<code>ReactCompositeComponentWrapper</code>是干什么的呢? 又和我们提到的<code>ReactCompositeComponent</code>有什么纠缠不清的关系呢? 下面几行代码就可以告诉你事情的真相:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactCompositeComponentWrapper = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.construct(element);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">  ReactCompositeComponentWrapper.prototype,</span><br><span class="line">  ReactCompositeComponent,</span><br><span class="line">  &#123;</span><br><span class="line">    _instantiateReactComponent: instantiateReactComponent,</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><code>ReactCompositeComponentWrapper</code>就跟他的名字一样, 是对<code>ReactCompositeComponent</code>这个类的一个包装类, 所有的类方法都来自于我们今天要说到的主角<code>ReactCompositeComponent</code>.</p><hr><h3 id="ReactCompositeComponent"><a href="#ReactCompositeComponent" class="headerlink" title="ReactCompositeComponent"></a><code>ReactCompositeComponent</code></h3><p>源码地址: <a href="https://github.com/facebook/react/blob/v15.6.2/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js" target="_blank" rel="noopener">ReactCompositeComponent.js</a></p><p>下面接着对<code>ReactCompositeComponent</code>做一下分析, 某些方法的具体内容会省略掉, 如果有需要可以自行查阅源码当中的具体代码, 方便节省篇幅以及更易于阅读.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactCompositeComponent = &#123;</span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;, <span class="comment">// 用于初始化组件的元信息(Metadata)</span></span><br><span class="line">  mountComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inst = <span class="keyword">this</span>._constructComponent(...); <span class="comment">// 生命周期函数的启动入口,</span></span><br><span class="line">    <span class="keyword">var</span> markup; <span class="comment">// render方法返回的ReactElement就是这个markup</span></span><br><span class="line">    markup = performInitialMount(...);</span><br><span class="line">    <span class="keyword">if</span> (inst.componentDidMount) inst.componentDidMount(); <span class="comment">// 第三个钩子函数调用</span></span><br><span class="line">    <span class="keyword">return</span> markup;</span><br><span class="line">  &#125;,</span><br><span class="line">  _constructComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;, <span class="comment">// 这个方法会调用下面这个方法</span></span><br><span class="line">  _constructComponentWithoutOwner: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Component(publicProps, publicContext, updateQueue); <span class="comment">// 被包起来的Component被实例化</span></span><br><span class="line">  &#125;,</span><br><span class="line">  performInitialMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ins = <span class="keyword">this</span>._instance;</span><br><span class="line">    <span class="keyword">if</span> (ins.componentWillMount) ins.componentWillMount(); <span class="comment">// 第一个钩子函数的调用</span></span><br><span class="line">    <span class="comment">// 比较重要的地方: 当在初始挂载的阶段如果有发现`setState`方法被调用, 便会通过同步的方式来处理, 很好的避免了setState导致的重新渲染, 来提高整体的性能.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._pendingStateQueue) &#123;</span><br><span class="line">      inst.state = <span class="keyword">this</span>._processPendingState(inst.props, inst.context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (renderedElement === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// 近似等于: renderedElement = this._instance.render();</span></span><br><span class="line">      renderedElement = <span class="keyword">this</span>._renderValidatedComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> child = <span class="keyword">this</span>._instantiateReactComponent(...) <span class="comment">// 递归实例化子组件</span></span><br><span class="line">    <span class="keyword">var</span> markup = ReactReconciler.mountComponent(child, ...); <span class="comment">// 递归得到完整的树.</span></span><br><span class="line">    <span class="keyword">return</span> markup;</span><br><span class="line">  &#125;,</span><br><span class="line">  _renderValidatedComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._renderValidatedComponentWithoutOwnerOrContext();</span><br><span class="line">  &#125;,</span><br><span class="line">  _renderValidatedComponentWithoutOwnerOrContext: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._instance.render(); <span class="comment">// 第二个钩子的调用</span></span><br><span class="line">  &#125;,</span><br><span class="line">  receiveComponent: <span class="function"><span class="keyword">function</span>(<span class="params">...</span>) </span>&#123; <span class="comment">// 调用该方法来更新Component</span></span><br><span class="line">    <span class="keyword">this</span>.updateComponent(...); </span><br><span class="line">  &#125;,</span><br><span class="line">  updateComponent: <span class="function"><span class="keyword">function</span>(<span class="params">...</span>) </span>&#123; <span class="comment">// 后面会讲到这些更新条件如何被满足</span></span><br><span class="line">    <span class="keyword">if</span> (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123;</span><br><span class="line">      inst.componentWillReceiveProps(); <span class="comment">// 第四个钩子函数的调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> shouldUpdate = inst.shouldComponentUpdate(); <span class="comment">// 第五个钩子函数调用</span></span><br><span class="line">    <span class="keyword">if</span> (shouldUpdate) <span class="keyword">this</span>._performComponentUpdate();</span><br><span class="line">  &#125;,</span><br><span class="line">  _performComponentUpdate: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    inst.componentWillUpdate(...); <span class="comment">// 第六个钩子函数的调用.</span></span><br><span class="line">    <span class="keyword">this</span>._updateRenderedComponent(...); <span class="comment">// 更新; 内部调用第七个钩子函数 Component.render();</span></span><br><span class="line">    inst.componentDidUpdate &amp;&amp; inst.componentDidUpdate(); <span class="comment">// 第八个个钩子函数调用</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 里面是Component更新的操作 简单来说就是销毁掉原有的节点, 然后重新实例化新的节点挂载.</span></span><br><span class="line">  _updateRenderedComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">  unmountComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 递归卸载节点, 调用子节点的 componentWillUnmount方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结:"></a>本章小结:</h4><p><code>ReactCompositeComponent</code> 的内容基本就是挂载/更新/卸载等操作. 除了<code>CompositeComponent</code>, 在<code>instantiateReactComponent</code>方法中, 能够看到React中一共有4种Component类型.</p><ol><li>ReactCompositeComponent<ul><li>InternalComponent. <code>// 可以理解为React的官方标准组件库</code></li><li>UserDefinedComponent <code>// 用户自定义</code></li></ul></li><li>ReactDOMComponent <code>// DOM节点相关的Component, 自定义的Component最后都会被处理成该类型的</code></li><li>ReactTextComponent <code>// 字面量节点, 如 &quot;Some string&quot; &quot;12312&quot;</code></li><li>ReactEmptyComponent <code>// 空节点</code></li></ol><hr><h4 id="下期预告-从React-render-的调用开始-到底发生了什么"><a href="#下期预告-从React-render-的调用开始-到底发生了什么" class="headerlink" title="下期预告: 从React.render()的调用开始, 到底发生了什么?"></a>下期预告: 从<code>React.render()</code>的调用开始, 到底发生了什么?</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;/strong&gt; &lt;code&gt;ReactCompositeComponent&lt;/code&gt; &lt;code&gt;instantiate&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;让我们先实例化一个组件&quot;&gt;&lt;a href=&quot;#让我们先实例化一个组件&quot; class=&quot;headerlink&quot; title=&quot;让我们先实例化一个组件&quot;&gt;&lt;/a&gt;让我们先实例化一个组件&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;/2018/07/20/React源码阅读系列-§1.3先给我整一个Component/&quot;&gt;上一章&lt;/a&gt;讲到了, React的&lt;code&gt;Component&lt;/code&gt;种类, 但没讲到用户自己写的&lt;code&gt;CustomComponent&lt;/code&gt;是怎么被实例化的. 在后面的章节会介绍到关于应用启动的过程到底发生了哪些事情, 在这边就先简单的做一个铺垫. 主要关注在&lt;code&gt;CustomComponent&lt;/code&gt;的实例化过程.&lt;/p&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>React源码阅读系列 - §1.3 先给我整一个 Component</title>
    <link href="https://jeremywu.info/2018/07/20/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A71.3%E5%85%88%E7%BB%99%E6%88%91%E6%95%B4%E4%B8%80%E4%B8%AAComponent/"/>
    <id>https://jeremywu.info/2018/07/20/React源码阅读系列-§1.3先给我整一个Component/</id>
    <published>2018-07-20T13:43:41.000Z</published>
    <updated>2018-07-20T17:35:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: </strong> <code>BaseComponent</code> <code>CustomComponent</code> <code>PureComponent</code> <code>Statelesscomponent</code></p><p>上回书说道, 所有人写的JSX(TSX)代码, 都会被对应的编译器给翻译成<code>React.createElement</code>形式的代码.<br>那么, 一个<code>CustomdComponent</code>是怎么样被React渲染的呢?</p><h4 id="来整懂嘛是一个ReactComponent"><a href="#来整懂嘛是一个ReactComponent" class="headerlink" title="来整懂嘛是一个ReactComponent"></a>来整懂嘛是一个ReactComponent</h4><a id="more"></a><hr><p>在开始之前, 先要公布一下<a href="/2018/07/18/React源码阅读系列-§1.2先有节点后有天%20ReactCreateElement/">上一篇</a>文章的练习题答案.</p><p>编译后代码如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render = <span class="function"><span class="params">()</span> =&gt;</span> React.createElement(</span><br><span class="line">                      <span class="string">'div'</span>, <span class="comment">// type</span></span><br><span class="line">                      &#123;<span class="attr">className</span>: <span class="string">'container'</span>&#125;, <span class="comment">// props</span></span><br><span class="line">                      React.createElement(            <span class="comment">//  - |</span></span><br><span class="line">                        <span class="string">'span'</span>,   <span class="comment">//type              //    |--&gt; children</span></span><br><span class="line">                        &#123;<span class="attr">className</span>: <span class="string">'sub'</span>&#125;, <span class="comment">// props  //  - |</span></span><br><span class="line">                        <span class="literal">null</span>) <span class="comment">// children</span></span><br><span class="line">                      );</span><br></pre></td></tr></table></figure></p><p>上面的方法运行出来的结果为: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>.for(<span class="string">'react.element'</span>)</span><br><span class="line">  type: <span class="string">'div'</span>,</span><br><span class="line">  key: <span class="literal">null</span>,</span><br><span class="line">  ref: <span class="literal">null</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">'container'</span>,</span><br><span class="line">    children: &#123;</span><br><span class="line">      $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>.for(<span class="string">'react.element'</span>)</span><br><span class="line">      type: <span class="string">'span'</span>,</span><br><span class="line">      key: <span class="literal">null</span>,</span><br><span class="line">      ref: <span class="literal">null</span>,</span><br><span class="line">      props: &#123;</span><br><span class="line">        className: <span class="string">'sub'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      _owner: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  _owner: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>&emsp;&emsp;&nbsp;在<strong>ES6</strong> A.K.A. <a href="https://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">ECMAScript2015®</a>以及更高版本的<a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm" target="_blank" rel="noopener">ECMAScript®</a>越来越普及的今天, 并且各种超集(Superset)/下一代编译器(Next Gen Compiler)如: <a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">Typescript®</a>, <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel®</a>的普及, 我们更多的是利用<code>class</code>语法来定义我们的<code>ReactComponent</code>, 而非早期版本的<code>React.createClass</code>, 且<code>React.createClass</code>在16.0+版本就已经被宣布废弃, 所以在这边就只对官方提供的三种Component:<br>&emsp;&emsp;&nbsp;&nbsp;i. <code>Component</code> 也叫 <code>BaseComponent</code><br>&emsp;&emsp;&nbsp;ii. <code>PureComponent</code><br>&emsp;&emsp;iii. <code>StatelessComponent</code> 也叫 <code>FunctionalComponent</code><br>做一个简单的分析.</p><h4 id="i-BaseComponent"><a href="#i-BaseComponent" class="headerlink" title="i. BaseComponent"></a>i. BaseComponent</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactComponent</span>(<span class="params">props, context, updater</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.props = props;</span><br><span class="line">  <span class="keyword">this</span>.context = context;</span><br><span class="line">  <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line">ReactComponent.prototype.isReactComponent = &#123;&#125;;</span><br><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// ...省略实现, 后面会专门讲这个方法</span></span><br><span class="line">ReactComponent.prototype.forceUpdate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">//.. 同上</span></span><br></pre></td></tr></table></figure><h4 id="ii-PureComponent"><a href="#ii-PureComponent" class="headerlink" title="ii. PureComponent"></a>ii. PureComponent</h4><p><code>PureComponent</code>其实基本上跟<code>ReactComponent</code>等价, 唯一不同的地方在这段代码, 而不同点将会在后面的文章当中对其进行介绍.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactPureComponent.prototype.isPureReactComponent = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><h4 id="iii-StatelessComponent"><a href="#iii-StatelessComponent" class="headerlink" title="iii. StatelessComponent"></a>iii. StatelessComponent</h4><p><code>StatelessComponent</code>较前两者而言由于不提供任何的生命周期函数, 在特定情况下的性能也许会比前两者稍微好一点. 其更大的优势是在于, 简化了<code>Component</code>本身的一个抽象过程, 可以减少非常多的代码量.</p><p>以上是React系统中用户可自定义的三种<code>Component</code>. 这三者其实并没有实际定义所谓的生命周期等函数. 详情请见下回分解.</p><hr><h4 id="下期预告-ReactCompositeComponent"><a href="#下期预告-ReactCompositeComponent" class="headerlink" title="下期预告: ReactCompositeComponent"></a>下期预告: <code>ReactCompositeComponent</code></h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;/strong&gt; &lt;code&gt;BaseComponent&lt;/code&gt; &lt;code&gt;CustomComponent&lt;/code&gt; &lt;code&gt;PureComponent&lt;/code&gt; &lt;code&gt;Statelesscomponent&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上回书说道, 所有人写的JSX(TSX)代码, 都会被对应的编译器给翻译成&lt;code&gt;React.createElement&lt;/code&gt;形式的代码.&lt;br&gt;那么, 一个&lt;code&gt;CustomdComponent&lt;/code&gt;是怎么样被React渲染的呢?&lt;/p&gt;
&lt;h4 id=&quot;来整懂嘛是一个ReactComponent&quot;&gt;&lt;a href=&quot;#来整懂嘛是一个ReactComponent&quot; class=&quot;headerlink&quot; title=&quot;来整懂嘛是一个ReactComponent&quot;&gt;&lt;/a&gt;来整懂嘛是一个ReactComponent&lt;/h4&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>React源码阅读系列 - §1.2先有节点后有天 ReactCreateElement</title>
    <link href="https://jeremywu.info/2018/07/18/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A71.2%E5%85%88%E6%9C%89%E8%8A%82%E7%82%B9%E5%90%8E%E6%9C%89%E5%A4%A9%20ReactCreateElement/"/>
    <id>https://jeremywu.info/2018/07/18/React源码阅读系列-§1.2先有节点后有天 ReactCreateElement/</id>
    <published>2018-07-18T14:18:17.000Z</published>
    <updated>2018-07-20T16:11:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键词:</strong> <code>ReactElement</code> <code>JSX</code></p><h3 id="一切都要从ReactDOM-render讲起"><a href="#一切都要从ReactDOM-render讲起" class="headerlink" title="一切都要从ReactDOM.render讲起"></a>一切都要从ReactDOM.render讲起</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Example <span class="keyword">from</span> <span class="string">'example'</span>;</span><br><span class="line">ReactDOM.render(&lt;Example/&gt;, <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>));</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h4 id="从一个错误说起"><a href="#从一个错误说起" class="headerlink" title="从一个错误说起"></a>从一个错误说起</h4><p>相信不少的人都犯过这样一个错误:<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; </span><br><span class="line">  </span><br><span class="line">  render() &#123;  </span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;Example&lt;/div&gt;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Error</span>: React is not defined.</span><br></pre></td></tr></table></figure></p><p>明明我这里并没有用到<code>React</code>这个关键字为什么会告诉我说<code>React is not defined</code>呢?</p><p>&emsp;&emsp;&nbsp;答案就是当你写JSX的代码时, 都是需要通过我们的一些编译工具把JSX代码编译成JavaScript代码, 这样浏览器才能够运行. 而这里的编译过程正好是用到了<code>React</code>这个库上所提供的<code>createElement</code>方法, 所以才会有上面这一行错误.</p><p>上面的代码等同于:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...省略</span></span><br><span class="line"><span class="keyword">class</span> SomeComponent <span class="keyword">extends</span> React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(<span class="string">'div'</span>, <span class="literal">null</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...省略</span></span><br></pre></td></tr></table></figure><hr><h4 id="具体分析createElement方法到底是干了什么"><a href="#具体分析createElement方法到底是干了什么" class="headerlink" title="具体分析createElement方法到底是干了什么"></a>具体分析<code>createElement</code>方法到底是干了什么</h4><p><code>createElement</code>方法的方法签名:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params"><span class="keyword">type</span>, config, children</span>)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>类型</th></tr></thead><tbody><tr><td>type</td><td><code>string</code> or <code>ReactCompositeComponent</code></td></tr><tr><td>config</td><td><code>any</code></td></tr><tr><td>children</td><td><code>any</code></td></tr><tr><td>返回值</td><td><code>ReactElement</code></td></tr></tbody></table><p>从函数签名上可以不难看出, 在构造节点时, <code>React</code> 是需要知道要构造的节点的<strong>类型</strong>, 节点需要用到的一些<strong>属性值</strong>, 以及节点的<strong>子节点</strong>, 然后返回了一个<code>ReactElement</code>实体.</p><div class="tip"><br>  注:&emsp;<strong>一个元素节点上的子节点可以看做该节点的属性值(Property).</strong><br></div><p>接下来进入方法内部, 看这个方法到底做了一些什么事情, 该方法最后返回的结果又是什么, 省略掉一部分无关紧要的代码, 某些代码格式为了篇幅稍有整改但不影响正确性.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">React.createElement = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">type</span>, config, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> propName;</span><br><span class="line">  <span class="keyword">var</span> props = &#123;&#125;, key = ref = self = source = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 传递属性</span></span><br><span class="line">  <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 关键属性, 后面会分析到.</span></span><br><span class="line">    <span class="keyword">if</span> (hasValidRef(config)) &#123;</span><br><span class="line">      ref = config.ref;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前节点是否具有有效的特殊key, key属性也是节点的保留属性, 为React的diff做了非常大的贡献</span></span><br><span class="line">    <span class="keyword">if</span> (hasValidKey(config)) &#123;</span><br><span class="line">      key = <span class="string">''</span> + config.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self = config.__self === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__self;</span><br><span class="line">    source = config.__source === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__source;</span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">      <span class="comment">// ... 省略属性的复制</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把子节点作为当前根节点上的属性</span></span><br><span class="line">  <span class="keyword">var</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 此处代码为本文作者调整 原始代码可参见文末给出地址</span></span><br><span class="line">    props.children = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理根节点上的默认的属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> &amp;&amp; <span class="keyword">type</span>.defaultProps) &#123;</span><br><span class="line">    <span class="comment">// ... 省略默认属性的复制</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个ReactElement节点</span></span><br><span class="line">  <span class="keyword">return</span> ReactElement(<span class="keyword">type</span>, key, ref, self, source, ReactCurrentOwner.current, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;&nbsp;透过这个方法其实不难看出, <code>React.createElement</code>整个方法内部, 都是在做一系列的数据处理, 然后把处理好的数据输入给<code>ReactElement</code>这个方法, 通过该方法来构造出一个真正的<code>ReactElement</code>节点.</p><hr><h5 id="ReactElement到底是个什么东西"><a href="#ReactElement到底是个什么东西" class="headerlink" title="ReactElement到底是个什么东西?"></a><code>ReactElement</code>到底是个什么东西?</h5><p>&emsp;&emsp;&nbsp;从上面最后一行可以看出来, 最后通过构造方法调用, 返回了一个真实的<code>ReactElement</code>, 这里其实可以看做一个类实例构造类似 省略掉<code>new</code>操作符的类构造器调用.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 这个markdown的支持可真烂</span></span><br><span class="line"><span class="keyword">var</span> ReactElement = <span class="function"><span class="keyword">function</span>(<span class="params">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    $$<span class="keyword">typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    props,</span><br><span class="line">    _owner: owner</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>$$typeof</td><td><code>Symbol</code></td><td>标识该对象是一个ReactElement</td></tr><tr><td>type</td><td><code>any</code></td><td>该Element的类型</td></tr><tr><td>key</td><td><code>string</code></td><td>标识该节点的独有key</td></tr><tr><td>ref</td><td><code>object</code> or <code>function</code></td><td>该节点对象的引用</td></tr><tr><td>props</td><td><code>object</code></td><td>该节点的所有属性</td></tr><tr><td>_owner</td><td><code>any</code></td><td>标识该节点的所有者</td></tr></tbody></table><hr><h4 id="最后的小测试"><a href="#最后的小测试" class="headerlink" title="最后的小测试:"></a>最后的小测试:</h4><p>尝试人为调用上述的<code>React.createElement</code>方法来得到一个<code>ReactElement</code>然后用树形结构表示出来, 答案在下一章开头.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sub"</span>&gt;</span>Text Node<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="下期预告-ReactComponent"><a href="#下期预告-ReactComponent" class="headerlink" title="下期预告: ReactComponent"></a>下期预告: ReactComponent</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键词:&lt;/strong&gt; &lt;code&gt;ReactElement&lt;/code&gt; &lt;code&gt;JSX&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;一切都要从ReactDOM-render讲起&quot;&gt;&lt;a href=&quot;#一切都要从ReactDOM-render讲起&quot; class=&quot;headerlink&quot; title=&quot;一切都要从ReactDOM.render讲起&quot;&gt;&lt;/a&gt;一切都要从ReactDOM.render讲起&lt;/h3&gt;&lt;figure class=&quot;highlight jsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; React &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; ReactDom &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react-dom&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Example &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;example&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ReactDOM.render(&amp;lt;Example/&amp;gt;, &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.querySelector(&lt;span class=&quot;string&quot;&gt;&#39;#root&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>React源码阅读系列 - §1.1 生命周期 Life cycle</title>
    <link href="https://jeremywu.info/2018/07/17/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A71.1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-Lifecycle/"/>
    <id>https://jeremywu.info/2018/07/17/React源码阅读系列-§1.1-生命周期-Lifecycle/</id>
    <published>2018-07-17T13:25:22.000Z</published>
    <updated>2018-07-17T16:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键词:</strong> <code>Lifecycle</code> <code>生命周期</code></p><h1 id="React的生命周期"><a href="#React的生命周期" class="headerlink" title="React的生命周期"></a>React的生命周期</h1><p>&emsp;&emsp;&nbsp;每一个软件都有他的生命周期, React也不例外, 从React的Tutorial就开始向每一个用户介绍React的生命周期, React的各种内嵌钩子函数的使用. 下面来详细介绍一下React的生命周期到底有哪几个过程.</p><a id="more"></a><h3 id="通过一张图来理解"><a href="#通过一张图来理解" class="headerlink" title="通过一张图来理解:"></a>通过一张图来理解:</h3><img src="/2018/07/17/React源码阅读系列-§1.1-生命周期-Lifecycle/lifecycle.png" title="lifecycle"><h3 id="通过一段注释来理解"><a href="#通过一段注释来理解" class="headerlink" title="通过一段注释来理解:"></a>通过一段注释来理解:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ------------------ The Life-Cycle of a Composite Component ------------------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - constructor: Initialization of state. The instance is now retained.</span></span><br><span class="line"><span class="comment"> *   - componentWillMount</span></span><br><span class="line"><span class="comment"> *   - render</span></span><br><span class="line"><span class="comment"> *   - [children's constructors]</span></span><br><span class="line"><span class="comment"> *     - [children's componentWillMount and render]</span></span><br><span class="line"><span class="comment"> *     - [children's componentDidMount]</span></span><br><span class="line"><span class="comment"> *     - componentDidMount</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       Update Phases:</span></span><br><span class="line"><span class="comment"> *       - componentWillReceiveProps (only called if parent updated)</span></span><br><span class="line"><span class="comment"> *       - shouldComponentUpdate</span></span><br><span class="line"><span class="comment"> *         - componentWillUpdate</span></span><br><span class="line"><span class="comment"> *           - render</span></span><br><span class="line"><span class="comment"> *           - [children's constructors or receive props phases]</span></span><br><span class="line"><span class="comment"> *         - componentDidUpdate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     - componentWillUnmount</span></span><br><span class="line"><span class="comment"> *     - [children's componentWillUnmount]</span></span><br><span class="line"><span class="comment"> *   - [children destroyed]</span></span><br><span class="line"><span class="comment"> * - (destroyed): The instance is now blank, released by React and ready for GC.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><div class="tip"><br><p>注:</p><br><br><p>i. 该注释出处为React 源码仓库中的<a href="https://github.com/facebook/react/blob/v15.6.2/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js#L88" target="_blank" rel="noopener">ReactCompositeComponent.js</a></p><br><p>ii. 通过用户编写的<strong>Component</strong>都是一个<strong>Composite Component</strong></p><br></div><h3 id="ReactComponent生命周期以及所对应的钩子函数-Hook"><a href="#ReactComponent生命周期以及所对应的钩子函数-Hook" class="headerlink" title="ReactComponent生命周期以及所对应的钩子函数(Hook)"></a>ReactComponent生命周期以及所对应的钩子函数(Hook)</h3><ol><li><p>Component 创建:<br>i. Component Constructor - 初始化State Props<br>ii. ComponentWillMount - Hook API<br>iii. render - 创建节点<br>iv. ComponentDidMount - Hook API</p></li><li><p>Component 更新<br>i. ShouldComponentUpdate - Hook API<br>ii. ComponentWillUpdate - Hook API<br>iii. render - 更新节点<br>iv. ComponentDidUpdate - Hook API</p></li><li><p>Component 销毁<br>i. ComponentWillUnmount - Hook API<br>ii. 类似 <code>someComponent = null;</code> - 等待GC</p></li></ol><h3 id="下期预告-React-createElement"><a href="#下期预告-React-createElement" class="headerlink" title="下期预告: React.createElement"></a>下期预告: <code>React.createElement</code></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键词:&lt;/strong&gt; &lt;code&gt;Lifecycle&lt;/code&gt; &lt;code&gt;生命周期&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;React的生命周期&quot;&gt;&lt;a href=&quot;#React的生命周期&quot; class=&quot;headerlink&quot; title=&quot;React的生命周期&quot;&gt;&lt;/a&gt;React的生命周期&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;nbsp;每一个软件都有他的生命周期, React也不例外, 从React的Tutorial就开始向每一个用户介绍React的生命周期, React的各种内嵌钩子函数的使用. 下面来详细介绍一下React的生命周期到底有哪几个过程.&lt;/p&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>React源码阅读系列 - §0 简介 Intro</title>
    <link href="https://jeremywu.info/2018/07/16/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A70%20%E7%AE%80%E4%BB%8B%20Intro/"/>
    <id>https://jeremywu.info/2018/07/16/React源码阅读系列-§0 简介 Intro/</id>
    <published>2018-07-16T13:43:51.000Z</published>
    <updated>2018-07-22T14:02:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键词:</strong> <code>React</code> <code>源码分析</code></p><h1 id="React-源码阅读"><a href="#React-源码阅读" class="headerlink" title="React 源码阅读"></a>React 源码阅读</h1><p><strong>&emsp;&emsp;&nbsp;最近由于工作变动, 被调到了新的部门, 新的部门里的很多代码并不熟悉, 便只能硬着头皮看下去, 随即发现了一个问题, 跳出舒适圈的我, 在看代码的过程中, 学到了非常多的东西, 想要想办法证明自己, 于是便想开这么一篇React的源码阅读的坑, 准备花一段时间来阅读以及记录自己对源码阅读后的理解和感悟.</strong></p><h3 id="React版本"><a href="#React版本" class="headerlink" title="React版本"></a>React版本</h3><div class="tip"><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Name"</span>: <span class="string">"React"</span>,</span><br><span class="line">  <span class="attr">"Version"</span>: <span class="string">"15.6.2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></div><a id="more"></a><h3 id="核心概念-Core-Concepts"><a href="#核心概念-Core-Concepts" class="headerlink" title="核心概念 (Core Concepts):"></a>核心概念 (Core Concepts):</h3><p><strong>0. 基础部分 (Pre-requirement)</strong></p><ul><li>生命周期</li><li>从 JSX (TSX) 到 JS</li></ul><p><strong>1. 启动部分 (在应用启动时的代码分析)</strong></p><ul><li>从组件 (<strong>Component</strong>) 到 虚拟节点 (<strong>Virtual Node</strong>)</li><li>从虚拟节点 (<strong>Virtual Node</strong>) 到 真实DOM节点 (<strong>Actual Node</strong>)</li></ul><p><strong>2. 存在周期 (在存在周期时的代码分析)</strong></p><ul><li>事件机制 (Event Handling)</li><li>事务处理 (Transaction Operation)</li><li>更新操作 (Updating Action)<br>i. 数据更新 (Data Updating)<br>ii. 视图更新 (Layout Updating)</li><li>组件间的通信 (Component Communication)</li><li>Diff的算法分析 (Diff Algorithm)</li></ul><p><strong>3. 总结</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键词:&lt;/strong&gt; &lt;code&gt;React&lt;/code&gt; &lt;code&gt;源码分析&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;React-源码阅读&quot;&gt;&lt;a href=&quot;#React-源码阅读&quot; class=&quot;headerlink&quot; title=&quot;React 源码阅读&quot;&gt;&lt;/a&gt;React 源码阅读&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&amp;emsp;&amp;emsp;&amp;nbsp;最近由于工作变动, 被调到了新的部门, 新的部门里的很多代码并不熟悉, 便只能硬着头皮看下去, 随即发现了一个问题, 跳出舒适圈的我, 在看代码的过程中, 学到了非常多的东西, 想要想办法证明自己, 于是便想开这么一篇React的源码阅读的坑, 准备花一段时间来阅读以及记录自己对源码阅读后的理解和感悟.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;React版本&quot;&gt;&lt;a href=&quot;#React版本&quot; class=&quot;headerlink&quot; title=&quot;React版本&quot;&gt;&lt;/a&gt;React版本&lt;/h3&gt;&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;Name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;React&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;Version&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;15.6.2&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
