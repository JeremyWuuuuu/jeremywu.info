<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeremy&#39;s Note</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jeremywu.info/"/>
  <updated>2019-03-31T15:49:32.000Z</updated>
  <id>https://jeremywu.info/</id>
  
  <author>
    <name>Jeremy Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>0b0001从分片调度来看React的调度机制</title>
    <link href="https://jeremywu.info/2019/03/31/0b0001%E4%BB%8E%E5%88%86%E7%89%87%E8%B0%83%E5%BA%A6%E6%9D%A5%E7%9C%8BReact%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/"/>
    <id>https://jeremywu.info/2019/03/31/0b0001从分片调度来看React的调度机制/</id>
    <published>2019-03-31T09:06:38.000Z</published>
    <updated>2019-03-31T15:49:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: <code>React</code> <code>Reconciler</code> <code>Scheduler</code> </strong></p><h2 id="分水岭-React-v16"><a href="#分水岭-React-v16" class="headerlink" title="分水岭 React v16"></a>分水岭 React v16</h2><p>React 16 与之前的版本最大的不同就在于 React 开发核心团队重写了 React 中相当核心的一部分: <strong>更新策略</strong></p><h3 id="Before-v16"><a href="#Before-v16" class="headerlink" title="Before v16"></a>Before v16</h3><h4 id="Javascript-与渲染引擎的关系"><a href="#Javascript-与渲染引擎的关系" class="headerlink" title="Javascript 与渲染引擎的关系"></a>Javascript 与渲染引擎的关系</h4><p>因为 Javascript 语言的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">并发模型</a>的特殊性, Javascript 的代码被放入执行之后, 就会一直跑到结束<br><a id="more"></a><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;</span><br><span class="line">  <span class="hljs-comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的代码会直接导致浏览器没有响应 (不要随意尝试). 由于执行 Javascript 和浏览器页面内容更新计算都是发生在主线程 (Main Thread), 当 Javascript 被执行完, 会生成新的 <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" target="_blank" rel="noopener">渲染树</a>, 整个过程如下图</p><blockquote><img src="/2019/03/31/0b0001从分片调度来看React的调度机制/frame-full.jpg" title="frame full"><center><strong>Fig.1 帧更新 (图片来自于 <a href="https://developer.google.com" target="_blank" rel="noopener">Google Developers</a>)</strong></center></blockquote><p>一般来讲, 这几个流程中的前三个过程都是发生在 CPU 中, 也就是所谓的 <code>Main Thread</code> 中, 剩下两个过程是将计算结果交由 GPU 来执行. 其中, 第三步 <code>layout</code> 也是可以跳过的, 具体的优化步骤可以参见<a href="https://developers.google.com/web/fundamentals/performance/rendering/" target="_blank" rel="noopener">渲染性能优化</a></p><h4 id="React-的更新调度策略"><a href="#React-的更新调度策略" class="headerlink" title="React 的更新调度策略"></a>React 的更新调度策略</h4><p>React 在 v16 之前的更新调度策略是, 每当有更新发生, 便会从启动本次更新的节点开始, 一直往下计算节点的变更, 直到最后一个节点被计算完 (这是一个递归过程), 才会根据计算出的新 <code>v-dom</code> 树去与旧树比较进行一轮批量更新, 然后该次更新完毕后, 新的渲染树被生成, 最终被画在了屏幕上. 过程如下图所示, 这个更新调度策略被大家称为 <code>栈调度 (stack reconciler)</code><br><img src="/2019/03/31/0b0001从分片调度来看React的调度机制/react-update-frame.jpg" title="react update frame"></p><center><strong>Fig.2 React 更新流程</strong></center><p>由于人眼对于动画的感知必须是在 <code>60 fps</code> 下才不会感觉到有卡顿, 也就是说每一帧(画面)更新的时间仅有 1000ms / 60 = <code>~16ms</code> 左右, 如果更新周期内浏览器主线程并没有时间来更新画面, 便会产生<code>抛弃帧 (frame drop)</code>, 也就是说, 当抛弃帧发生时, 用户看到的动画会突然从一个位置飞到另一个位置, 造成卡顿(jank).<br>正是由于 Javascript 的特殊性, 如果当前更新的节点较多 (亦或是计算足够复杂消耗 CPU), 那么即使 React 本身有着足够优越的性能, 也没有办法避免抛弃帧的发生, 一旦更新任务耗时太久, 或者计算非常复杂, 主线程就会被阻塞, 这样一来, 用户的交互也没有办法得到响应 (如: 选择, 输入等).<br>正因如此, React 核心团队决定重构 React 的更新调度策略…</p><h3 id="After-v16"><a href="#After-v16" class="headerlink" title="After v16"></a>After v16</h3><h4 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h4><p>得益于 React 中的 <code>v-dom</code>, React 的性能十分出色, 但由于用户代码对于 React 来说<strong>实在是太不可控</strong>, 并且 React 也实在是没有办法能够去强制规定使用者的代码风格(质量), 于是 React 的核心团队决定让 React 更快, 并且不会因为更新任务过于繁重从而造成主线程无响应. 所以 <code>Fiber</code> 被引进了</p><ul><li>Fiber 是一种编程思想, 是一种<strong>非抢占式</strong>的多线程模型, 和 <code>CoRoutine</code> 是同一个概念</li><li>React Fiber 中的概念是, React Fiber 会主动退出更新任务的运行, 从而交还给浏览器去做更新操作, 当浏览器操作结束后, 会主动将控制权返还给 React Fiber, 进而继续更新工作.</li><li>React Fiber 的调度器是通过 <code>requestAnimationFrame</code> 和 <code>setTimeout</code> 来实现的.</li></ul><img src="/2019/03/31/0b0001从分片调度来看React的调度机制/fiber_work_loop.png" title="fiber work loop"><center>Made with ❤️ by Lin Clark at ReactConf 2017</center><h4 id="Phase"><a href="#Phase" class="headerlink" title="Phase"></a>Phase</h4><p>Fiber 将更新分为两个阶段</p><h5 id="Computation"><a href="#Computation" class="headerlink" title="Computation"></a>Computation</h5><p>这个阶段是 React 计算哪些地方需要更新的阶段, 这个阶段是可以被打断的阶段, 也就是说, 在这个阶段, React 更新每运行一小段时间, 就会将控制权交还给浏览器去响应交互或更新, 然后再空闲时间回到当前的更新阶段, 但是, 由于跟响应用户交互时, 可能会有新的更新插入, 于是之前计算过的那些计算结果可能就没有办法使用了, 之前的计算结果就会被抛弃, 重新进行计算. 并且, 在这些的基础之上, 更新的操作也是有着优先级之分的, 优先级高的更新优先被计算, 优先级低的必须等优先级高的被计算完之后才能被计算.<br>这也是为什么 <code>componentWillMount</code>, <code>UNSTABLE_componentWillUpdate</code> 会被多次调用的原因.</p><h5 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h5><p>这个阶段是实际触发 DOM 更新的阶段, 并且该阶段不会被打断, 也就是说, 一旦进入这个阶段, 更新就会被全部完成, 浏览器在收到更新的通知之后便会去更新页面.</p><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>经历这两个阶段, 一次更新也就算完成了, 但由于阶段一存在优先级, 一个新的问题又被引入了, 那就是 <code>Starving Task</code>, 这是由于如果一直有优先级高的更新插入队列中, 那么优先级低的更新就永远无法被触发, 就会引起一系列的问题.</p><h3 id="UpComing"><a href="#UpComing" class="headerlink" title="UpComing..."></a><code>UpComing...</code></h3><p><a href="">React Fiber 调度器的实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;code&gt;React&lt;/code&gt; &lt;code&gt;Reconciler&lt;/code&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;分水岭-React-v16&quot;&gt;&lt;a href=&quot;#分水岭-React-v16&quot; class=&quot;headerlink&quot; title=&quot;分水岭 React v16&quot;&gt;&lt;/a&gt;分水岭 React v16&lt;/h2&gt;&lt;p&gt;React 16 与之前的版本最大的不同就在于 React 开发核心团队重写了 React 中相当核心的一部分: &lt;strong&gt;更新策略&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;Before-v16&quot;&gt;&lt;a href=&quot;#Before-v16&quot; class=&quot;headerlink&quot; title=&quot;Before v16&quot;&gt;&lt;/a&gt;Before v16&lt;/h3&gt;&lt;h4 id=&quot;Javascript-与渲染引擎的关系&quot;&gt;&lt;a href=&quot;#Javascript-与渲染引擎的关系&quot; class=&quot;headerlink&quot; title=&quot;Javascript 与渲染引擎的关系&quot;&gt;&lt;/a&gt;Javascript 与渲染引擎的关系&lt;/h4&gt;&lt;p&gt;因为 Javascript 语言的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;并发模型&lt;/a&gt;的特殊性, Javascript 的代码被放入执行之后, 就会一直跑到结束&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React16逆向系列" scheme="https://jeremywu.info/categories/React16%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="react16.x 源码逆向" scheme="https://jeremywu.info/tags/react16-x-%E6%BA%90%E7%A0%81%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>react 16 逆向系列</title>
    <link href="https://jeremywu.info/2019/03/28/react-16/"/>
    <id>https://jeremywu.info/2019/03/28/react-16/</id>
    <published>2019-03-28T15:43:00.000Z</published>
    <updated>2019-03-31T15:44:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: <code>React</code> <code>Fiber</code> <code>Hooks</code> </strong></p><h2 id="react-16-x-逆向工程"><a href="#react-16-x-逆向工程" class="headerlink" title="react 16.x 逆向工程"></a>react 16.x 逆向工程</h2><p>上一部逆向的坑还没填完, 又开下一个坑, -&gt;_-&gt; 这次来逆向一下 <code>16.x</code> 版本的 React,在这个目录文写出来的时候, React 在线上的正式版本是 <code>16.8.10</code>, 希望到这个系列写完之前, React 都不会发布 <code>17.0 beta</code> 版本. 实际上 React 16.x 版本的源码相较于 15.x 时期, 不论代码组织, 还是代码质量上又更上了一层楼, 更引进了很多新的东西</p><ul><li>lazy, memo, contextType</li><li>Hooks 本版本除 Fiber 以外最重大的 feature (个人角度)</li><li>Profiler, Suspense</li><li>Brand new Context</li></ul><a id="more"></a><h4 id="0b0001-从分片调度来看-React-的调度机制"><a href="#0b0001-从分片调度来看-React-的调度机制" class="headerlink" title="0b0001 从分片调度来看 React 的调度机制"></a>0b0001 <a href="/2019/03/31/0b0001从分片调度来看React的调度机制/">从分片调度来看 React 的调度机制</a></h4><h4 id="0b0010-React-Fiber-调度器的实现-施工中🚧-…"><a href="#0b0010-React-Fiber-调度器的实现-施工中🚧-…" class="headerlink" title="0b0010  React Fiber 调度器的实现 (施工中🚧 …)"></a>0b0010 <a href=""> React Fiber 调度器的实现 (施工中🚧 …)</a></h4><h4 id="后续目录待补全"><a href="#后续目录待补全" class="headerlink" title="后续目录待补全"></a>后续目录待补全</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;code&gt;React&lt;/code&gt; &lt;code&gt;Fiber&lt;/code&gt; &lt;code&gt;Hooks&lt;/code&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;react-16-x-逆向工程&quot;&gt;&lt;a href=&quot;#react-16-x-逆向工程&quot; class=&quot;headerlink&quot; title=&quot;react 16.x 逆向工程&quot;&gt;&lt;/a&gt;react 16.x 逆向工程&lt;/h2&gt;&lt;p&gt;上一部逆向的坑还没填完, 又开下一个坑, -&amp;gt;_-&amp;gt; 这次来逆向一下 &lt;code&gt;16.x&lt;/code&gt; 版本的 React,在这个目录文写出来的时候, React 在线上的正式版本是 &lt;code&gt;16.8.10&lt;/code&gt;, 希望到这个系列写完之前, React 都不会发布 &lt;code&gt;17.0 beta&lt;/code&gt; 版本. 实际上 React 16.x 版本的源码相较于 15.x 时期, 不论代码组织, 还是代码质量上又更上了一层楼, 更引进了很多新的东西&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lazy, memo, contextType&lt;/li&gt;
&lt;li&gt;Hooks 本版本除 Fiber 以外最重大的 feature (个人角度)&lt;/li&gt;
&lt;li&gt;Profiler, Suspense&lt;/li&gt;
&lt;li&gt;Brand new Context&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="React16逆向系列" scheme="https://jeremywu.info/categories/React16%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="react16.x 源码逆向" scheme="https://jeremywu.info/tags/react16-x-%E6%BA%90%E7%A0%81%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Rust 函数</title>
    <link href="https://jeremywu.info/2019/03/16/Rust-%E5%87%BD%E6%95%B0/"/>
    <id>https://jeremywu.info/2019/03/16/Rust-函数/</id>
    <published>2019-03-16T15:38:24.000Z</published>
    <updated>2019-03-31T06:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: </strong> <code>Rust</code> <code>函数</code></p><p>函数是编程语言中对于某些现象或过程的抽象, 函数在 Rust 中扮演着重要的作用, 与 <code>Javascript</code> 相同, 函数在 Rust 中也是作为<a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">一等公民</a>的存在, 这也正意味着, Rust 中的函数可以被作为一个数据类型在程序中穿插传递.</p><a id="more"></a><h3 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h3><p>在 Rust 中, 无论是在特性中, 还是 <code>impl</code> 块中, 或是在其他地方声明一个函数, 都是使用一样的写法, 和 <code>Javascript</code> 不同(既有函数声明, 也有函数表达式).<br>Rust 中的函数声明: <code>fn name(arg: type) -&gt; returnType { body block }</code></p><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(a: <span class="hljs-built_in">isize</span>, b: <span class="hljs-built_in">isize</span>) -&gt; <span class="hljs-built_in">isize</span> &#123;</span><br><span class="line">  a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数做为参数"><a href="#函数做为参数" class="headerlink" title="函数做为参数"></a>函数做为参数</h4><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> </span>&lt;T&gt;inner_add(a: T, b: T, add: <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(a: T, b: T) -&gt; T) -&gt; T &#123;</span><br><span class="line">  add(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inner_add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, |a, b| a + b);</span><br></pre></td></tr></table></figure><h4 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h4><p>声明一个函数, 并且返回一个返回值, 在大多数语言中都需要用到, <code>return</code> 这个关键字, 但在 Rust 中, 这个关键字可以省略掉, 用更简单的方式返回. 如例子:</p><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(a: <span class="hljs-built_in">i32</span>, b: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> &#123;</span><br><span class="line">  a + b <span class="hljs-comment">// 注意这里没有跟分分号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者显式地返回这个语句</p><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(a: <span class="hljs-built_in">i32</span>, b: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> a + b; <span class="hljs-comment">// 注意这里跟分号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tip"><br>但是如果在函数块中, 最后一条语句以 <code>;</code> 结尾, 并没有 <code>return</code> 关键字, 那么编译器便会自动在代码中插入 <code>()</code> 这个特殊的元组作为返回值, 所以如果一个函数没有声明返回值, 都会以一个 <code>()</code> 作为返回, 当然, 这也是可选择的, 若不想要函数返回任何值, 可以将返回值设置成 <code>!</code>, 代表这个函数不返回任何值.<br></div><p><code>return</code> 关键字实际也是很有用的, 比如在一段条件语句中, 提前返回结果</p><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">ahead_return</span></span>() -&gt; <span class="hljs-built_in">String</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> i == <span class="hljs-number">5</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-string">"ahead returned"</span>.to_string(); <span class="hljs-comment">// 提前返回</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-string">"normal returned"</span>.to_string() <span class="hljs-comment">//直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回多个值的函数"><a href="#返回多个值的函数" class="headerlink" title="返回多个值的函数"></a>返回多个值的函数</h4><p>在 Rust 中, 一个函数的返回,  可以没有值, 可以有一个值, 也可以是多个值, 在 Rust 中, 函数要返回多个值, 可以直接采用返回一个元组, 如果函数没有返回值.</p><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">tuple_return</span></span>() -&gt; (<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>) &#123;</span><br><span class="line">  (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回函数的函数"><a href="#返回函数的函数" class="headerlink" title="返回函数的函数"></a>返回函数的函数</h4><p>同样, Rust 不止可以传入函数作为参数, 还能够返回一个函数作为返回值.</p><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">is_one</span></span> = <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(arg: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">bool</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">returned</span></span>(arg: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">bool</span> &#123;</span><br><span class="line">  arg == <span class="hljs-number">1i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">caller</span></span>() -&gt; is_one &#123;</span><br><span class="line">  returned</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, caller()(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 是不是有一股很熟悉的感觉</span></span><br></pre></td></tr></table></figure><h3 id="作用域与生命周期"><a href="#作用域与生命周期" class="headerlink" title=" 作用域与生命周期"></a> 作用域与生命周期</h3><p>在介绍闭包之前, 需要先介绍一下 Rust 中的作用域相关的知识.</p><p>Rust 中所有的作用域都是<strong>静态作用域 (Lexical Scope)</strong>, 通过成对的花括号来创建一个新的作用域</p><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(a: <span class="hljs-built_in">i32</span>, b: <span class="hljs-built_in">i32</span>) &#123;</span><br><span class="line">  <span class="hljs-comment">// 作用域 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="hljs-comment">// 作用域 2</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="hljs-comment">// 作用域 3</span></span><br><span class="line">      <span class="hljs-keyword">let</span> s = <span class="hljs-string">"some string"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 作用域 3 退出, s 被释放</span></span><br><span class="line">    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, s); <span class="hljs-comment">// error[E0425]: cannot find value `s` in this scope</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包 (Closure)"></a>闭包 (Closure)</h3><p>在 Rust 中的闭包又叫做一个匿名函数, 但闭包和普通的函数有几点不同</p><ul><li>能够捕捉调当前作用域里的变量</li><li>编译器能够自动推断输入和返回</li></ul><p>在 Rust 中最常用到闭包的地方就是产生子线程, 和迭代器的一些操作:<br>如: 产生一个子线程, 然后计算返回<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">use</span> std::thread;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;</span><br><span class="line">  <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Parent string"</span>);</span><br><span class="line">  <span class="hljs-keyword">let</span> child = thread::spawn(<span class="hljs-keyword">move</span> || &#123;</span><br><span class="line">    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"String from parent thread &#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="hljs-comment">// some work here</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"child thread string"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="hljs-comment">// some work here</span></span><br><span class="line">  <span class="hljs-keyword">let</span> res = child.join();</span><br><span class="line">  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, a); <span class="hljs-comment">// error[E0382]: borrow of moved value: `a`</span></span><br><span class="line">  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, res.unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子还展示了闭包的 <code>move</code> 关键字, 这个关键字可以把闭包函数体中用到过的变量的所有权转移到闭包内, 这样一来, 闭包外的变量的所有权就被转移了, 因此, 这个变量也不存在于这个作用域中, 它的生命周期就属于当前这个闭包的作用域, 当闭包退出的时候, 那么这个变量也被回收了.<br>或者对迭代器做操作<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> mapped: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = v.into_iter().map(|val| val + <span class="hljs-number">1</span> ).collect();</span><br><span class="line"><span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, mapped); <span class="hljs-comment">// [2, 3, 4, 5, 6, 7, 8, 9, 10, 11];</span></span><br></pre></td></tr></table></figure></p><p><br>这些都是很典型的闭包用例, 同函数一样, 闭包既可以作为参数, 也可以作为返回. 这些也只是 Rust 语言中函数使用的冰山一角, 函数有非常强大的功能.</p><h4 id="To-be-continued-…"><a href="#To-be-continued-…" class="headerlink" title="To be continued …"></a>To be continued …</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;/strong&gt; &lt;code&gt;Rust&lt;/code&gt; &lt;code&gt;函数&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;函数是编程语言中对于某些现象或过程的抽象, 函数在 Rust 中扮演着重要的作用, 与 &lt;code&gt;Javascript&lt;/code&gt; 相同, 函数在 Rust 中也是作为&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一等公民&lt;/a&gt;的存在, 这也正意味着, Rust 中的函数可以被作为一个数据类型在程序中穿插传递.&lt;/p&gt;
    
    </summary>
    
      <category term="Rust lang" scheme="https://jeremywu.info/categories/Rust-lang/"/>
    
    
      <category term="Rust" scheme="https://jeremywu.info/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust 运算符</title>
    <link href="https://jeremywu.info/2019/03/13/Rust-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://jeremywu.info/2019/03/13/Rust-运算符/</id>
    <published>2019-03-13T14:22:26.000Z</published>
    <updated>2019-03-31T06:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: </strong> <code>Rust</code> <code>运算符</code> <code>特性</code> <code>重载</code></p><p>在 Rust 里, 有很多不一样的操作符, 类似 <code>+</code> <code>-</code> <code>*</code> <code>/</code> 运算符, 每个运算符在不同的应用条件下表达的意思也可能不一样, 而 Rust 中的运算符很特殊, Rust 中的<a href="https://zh.wikipedia.org/wiki/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" target="_blank" rel="noopener">运算符支持重载</a>, 运算符重载这个特性在大部分语言中都没有得到支持, 而 Rust 支持了这一特殊的特性.</p><a id="more"></a><h3 id="Rust-中的运算符"><a href="#Rust-中的运算符" class="headerlink" title="Rust 中的运算符"></a>Rust 中的运算符</h3><table><thead><tr><th>运算符</th><th>举例</th><th>描述</th><th>重载方法</th></tr></thead><tbody><tr><td>!</td><td>ident!(…),<br>ident!{…},<br>ident![…]</td><td>Macro expansion    </td></tr><tr><td>!</td><td>!expr</td><td>Bitwise or logical complement</td><td>Not</td></tr><tr><td>!=</td><td>var != expr</td><td>Nonequality comparison</td><td>PartialEq</td></tr><tr><td>%</td><td>expr % expr</td><td>Arithmetic remainder</td><td>Rem</td></tr><tr><td>%=</td><td>var %= expr</td><td>Arithmetic remainder and assignment</td><td>RemAssign</td></tr><tr><td>&amp;</td><td>&amp;expr, &amp;mut expr</td><td>Borrow    </td></tr><tr><td>&amp;</td><td>&amp;type, <br>&amp;mut type, <br>&amp;’a type, <br>&amp;’a mut type</td><td>Borrowed pointer type    </td></tr><tr><td>&amp;</td><td>expr &amp; expr</td><td>Bitwise AND</td><td>BitAnd</td></tr><tr><td>&amp;=</td><td>var &amp;= expr</td><td>Bitwise AND and assignment</td><td>BitAndAssign</td></tr><tr><td>&amp;&amp;</td><td>expr &amp;&amp; expr</td><td>Logical AND    </td></tr><tr><td>*</td><td>expr * expr</td><td>Arithmetic multiplication</td><td>Mul</td></tr><tr><td>*=</td><td>var *= expr</td><td>Arithmetic multiplication and assignment</td><td>MulAssign</td></tr><tr><td>*</td><td>*expr</td><td>Dereference    </td></tr><tr><td>*</td><td><em>const type, </em>mut type</td><td>Raw pointer    </td></tr><tr><td>+</td><td>trait + trait, <br>‘a + trait</td><td>Compound type constraint    </td></tr><tr><td>+</td><td>expr + expr</td><td>Arithmetic addition</td><td>Add</td></tr><tr><td>+=</td><td>var += expr</td><td>Arithmetic addition and assignment</td><td>AddAssign</td></tr><tr><td>,</td><td>expr, expr</td><td>Argument and element separator    </td></tr><tr><td>-</td><td>- expr</td><td>Arithmetic negation</td><td>Neg</td></tr><tr><td>-</td><td>expr - expr</td><td>Arithmetic subtraction</td><td>Sub</td></tr><tr><td>-=</td><td>var -= expr</td><td>Arithmetic subtraction and assignment</td><td>SubAssign</td></tr><tr><td>-&gt;</td><td>fn(…) -&gt; type, <br> &#124;…&#124; -&gt; type</td><td>Function and closure return type    </td></tr><tr><td>.</td><td>expr.ident</td><td>Member access    </td></tr><tr><td>..</td><td>.., <br>expr..,<br> ..expr,<br> expr..expr</td><td>Right-exclusive range literal    </td></tr><tr><td>..=</td><td>..=expr, expr..=expr</td><td>Right-inclusive range literal    </td></tr><tr><td>..</td><td>..expr</td><td>Struct literal update syntax    </td></tr><tr><td>..</td><td>variant(x, ..), struct_type { x, .. }</td><td>“And the rest” pattern binding    </td></tr><tr><td>…</td><td>expr…expr</td><td>In a pattern: inclusive range pattern    </td></tr><tr><td>/</td><td>expr / expr</td><td>Arithmetic division</td><td>Div</td></tr><tr><td>/=</td><td>var /= expr</td><td>Arithmetic division and assignment</td><td>DivAssign</td></tr><tr><td>:</td><td>pat: type, ident: type</td><td>Constraints    </td></tr><tr><td>:</td><td>ident: expr</td><td>Struct field initializer    </td></tr><tr><td>:</td><td>‘a: loop {…}</td><td>Loop label    </td></tr><tr><td>;</td><td>expr;</td><td>Statement and item terminator    </td></tr><tr><td>;</td><td>[…; len]</td><td>Part of fixed-size array syntax    </td></tr><tr><td>&lt;&lt;</td><td>expr &lt;&lt; expr</td><td>Left-shift</td><td>Shl</td></tr><tr><td>&lt;&lt;=</td><td>var &lt;&lt;= expr</td><td>Left-shift and assignment</td><td>ShlAssign</td></tr><tr><td>&lt;</td><td>expr &lt; expr</td><td>Less than comparison</td><td>PartialOrd</td></tr><tr><td>&lt;=</td><td>expr &lt;= expr</td><td>Less than or equal to comparison</td><td>PartialOrd</td></tr><tr><td>=</td><td>var = expr, ident = type</td><td>Assignment/equivalence    </td></tr><tr><td>==</td><td>expr == expr</td><td>Equality comparison</td><td>PartialEq</td></tr><tr><td>=&gt;</td><td>pat =&gt; expr</td><td>Part of match arm syntax    </td></tr><tr><td>&gt;</td><td>expr &gt; expr</td><td>Greater than comparison</td><td>PartialOrd</td></tr><tr><td>&gt;=</td><td>expr &gt;= expr</td><td>Greater than or equal to comparison</td><td>PartialOrd</td></tr><tr><td>&gt;&gt;</td><td>expr &gt;&gt; expr</td><td>Right-shift</td><td>Shr</td></tr><tr><td>&gt;&gt;=</td><td>var &gt;&gt;= expr</td><td>Right-shift and assignment</td><td>ShrAssign</td></tr><tr><td>@</td><td>ident @ pat</td><td>Pattern binding    </td></tr><tr><td>^</td><td>expr ^ expr</td><td>Bitwise exclusive OR</td><td>BitXor</td></tr><tr><td>^=</td><td>var ^= expr</td><td>Bitwise exclusive OR and assignment</td><td>BitXorAssign</td></tr><tr><td>&#124;</td><td>pat &#124; pat</td><td>Pattern alternatives    </td></tr><tr><td>&#124;</td><td>expr &#124; expr</td><td>Bitwise OR</td><td>BitOr</td></tr><tr><td>&#124;=</td><td>var &#124;= expr</td><td>Bitwise OR and assignment</td><td>BitOrAssign</td></tr><tr><td>&#124;&#124;</td><td>expr &#124;&#124; expr</td><td>Logical OR    </td></tr><tr><td>?</td><td>expr?</td><td>Error propagation    </td></tr></tbody></table><p>这些可重载的操作符的特性都在 <code>std::ops</code> 这个包中被导出. </p><h3 id="一元运算符-Unary-Operator"><a href="#一元运算符-Unary-Operator" class="headerlink" title="一元运算符 (Unary Operator)"></a>一元运算符 (Unary Operator)</h3><p>当运算符作为<a href="https://zh.wikipedia.org/wiki/%E4%B8%80%E5%85%83%E9%81%8B%E7%AE%97" target="_blank" rel="noopener">一元运算符</a>时, 没有重载的操作.</p><ul><li><code>*</code> <code>&amp;</code> 这一对运算符作为一元运算符的时候是一对作用相反的运算符.<ul><li><code>&amp;</code> 运算符用于取引用, 也就是 Rust 中的 <code>Borrow</code> 概念, 可以大致理解为 C/C++ 中的取址操作;</li><li><code>*</code> 运算符用于解引用.</li></ul></li><li><code>-</code> 运算符用于取负数, 用于 integer/float 类型.</li><li><code>!</code> 位取反运算符, 将运算对象按位取反 如 <code>!b0000_0001</code> 结果为 <code>b1111_1110</code>;</li></ul><h3 id="二元运算符-Binary-Operator"><a href="#二元运算符-Binary-Operator" class="headerlink" title="二元运算符 (Binary Operator)"></a>二元运算符 (Binary Operator)</h3><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> 和其它语言中的算数运算符一模一样, 用于算术运算</p><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p><code>&amp;</code> <code>|</code> <code>^</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> 位运算符也几乎和 C/C++ 语言中的位运算符一样.</p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p><code>&gt;</code> <code>&gt;=</code> <code>==</code> <code>!=</code> <code>&lt;=</code> <code>&lt;</code> 这些运算符用于值的比较, 要注意的地方是比较运算也必须要发生在同一种类型的值之间, 如 <code>8i32 &lt; 9i64</code> 这样的比较是会被编译器抛错的. 比较运算符会产生一个 <code>bool</code> 类型的值</p><h4 id="断言运算符"><a href="#断言运算符" class="headerlink" title="断言运算符"></a>断言运算符</h4><p><code>&amp;&amp;</code> <code>||</code> 作为逻辑短路断言运算符, 和其它语言中的作用是一样的, 但是 <code>expr &amp;&amp; expr</code> 中的 <code>expr</code> 必须是 <code>bool</code> 类型, 这点是和其它语言不一样的地方.</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载实际上通常只是一种 <strong><u>语法糖</u></strong>. 它可以简单地通过函数调用来模拟<br>如<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + b * c <span class="hljs-comment">// a b c 均不是数值类型 但却支持用运算符</span></span><br></pre></td></tr></table></figure></p><p>模拟<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(a, multiply(b, c)) <span class="hljs-comment">// 假设乘法优先级是高于加法的</span></span><br></pre></td></tr></table></figure></p><p>假设我们需要去实现加法的重载, 我们就必须要用到 <code>Add</code> 这个特性, <code>Add</code> 这个 特性的签名是:<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 这里的 RHS 泛型 默认值是 Self 也就是当前实现这个特性的类型</span></span><br><span class="line"><span class="hljs-comment">// 同样, 你也可以指定这个地方的 RHS 为别的类型</span></span><br><span class="line"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Add</span></span>&lt;RHS = <span class="hljs-keyword">Self</span>&gt; &#123;</span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span>; <span class="hljs-comment">// 这个类型是用来定义返回值的</span></span><br><span class="line">  [must_use]  </span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, rhs: RHS) -&gt; Self::Output; <span class="hljs-comment">// 实现 Add 特性必须要实现 add 这个方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 Rust 中的重载实际很简单, 如我们要实现加法运算的重载就可以这样:<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">use</span> std::ops::Add; <span class="hljs-comment">// 载入 Add 特性</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#[derive(Debug, Clone, Copy)]</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> &#123;</span><br><span class="line">  a: <span class="hljs-built_in">u32</span>,</span><br><span class="line">  b: <span class="hljs-built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">impl</span> Add <span class="hljs-keyword">for</span> Foo &#123;</span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = Foo;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, rhs: Foo) -&gt; Foo &#123; <span class="hljs-comment">// rhs = right hand side</span></span><br><span class="line">    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Add 运算符重载!"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> Foo &#123;</span><br><span class="line">      a: <span class="hljs-keyword">self</span>.a + rhs.a,</span><br><span class="line">      b: <span class="hljs-keyword">self</span>.b + rhs.b</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这些就是 Rust 中的运算符, 运算符有非常多, 需要花时间去记忆, 有很多不常用但非常好用的运算符, 需要靠在实践中多使用, 慢慢会熟悉起来.</p><h4 id="To-be-continued-…"><a href="#To-be-continued-…" class="headerlink" title="To be continued …"></a>To be continued …</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;/strong&gt; &lt;code&gt;Rust&lt;/code&gt; &lt;code&gt;运算符&lt;/code&gt; &lt;code&gt;特性&lt;/code&gt; &lt;code&gt;重载&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 Rust 里, 有很多不一样的操作符, 类似 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; 运算符, 每个运算符在不同的应用条件下表达的意思也可能不一样, 而 Rust 中的运算符很特殊, Rust 中的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;运算符支持重载&lt;/a&gt;, 运算符重载这个特性在大部分语言中都没有得到支持, 而 Rust 支持了这一特殊的特性.&lt;/p&gt;
    
    </summary>
    
      <category term="Rust lang" scheme="https://jeremywu.info/categories/Rust-lang/"/>
    
    
      <category term="Rust" scheme="https://jeremywu.info/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust 控制流</title>
    <link href="https://jeremywu.info/2019/03/12/Rust%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <id>https://jeremywu.info/2019/03/12/Rust的控制流/</id>
    <published>2019-03-12T15:20:00.000Z</published>
    <updated>2019-03-31T06:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: </strong> <code>Rust</code> <code>控制流</code></p><p>代码跑与不跑, 跑了之后的结果是什么, 都依赖于控制流, Rust 中的控制流分为两大类</p><ul><li>判断</li><li>循环</li></ul><a id="more"></a><h3 id="判断表达式"><a href="#判断表达式" class="headerlink" title="判断表达式"></a>判断表达式</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>在 Rust 中, <code>if</code> 从句不是一个声明语句, 是一个表达式, 与 Java/Javascript 中的 if 不同:<br>Rust 中:<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> number = <span class="hljs-number">10</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">if</span> number &lt; <span class="hljs-number">10</span> &#123;</span><br><span class="line">  <span class="hljs-number">20</span></span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">  <span class="hljs-number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Javascript 中:<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> number = <span class="hljs-number">10</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> a;</span><br><span class="line"><span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">10</span>) &#123;</span><br><span class="line">  a = <span class="hljs-number">20</span>;</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">  a = <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a>if let</h4><p><code>if</code> 从句还有一个特殊的分支 就是 <code>if let</code>, 实际上这个写法是对接下来要讲的 <code>match</code> 的一个简写<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> a = <span class="hljs-literal">Some</span>(<span class="hljs-string">"b"</span>);</span><br><span class="line"><span class="hljs-comment">// 这里实际上是一个匹配的解构, 在下面会说到</span></span><br><span class="line"><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(val) = a &#123;</span><br><span class="line">  <span class="hljs-string">"equal"</span> <span class="hljs-comment">// 不能有分号, 因为是返回值</span></span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">  <span class="hljs-string">"not equal"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="tip"><br><p>1. Rust 中的 <code>if</code> 是<strong>表达式</strong>而不是声明语句</p><br><p>2. Rust 中的 <code>if</code> 后接续的条件只能是 <code>bool</code> 类型, 而不能像 <code>Javascript</code> 一样任意类型的值都可以.</p><br></div><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p><code>match</code> <strong>表达式</strong>在 Rust 中就像 Javascript 中的 <code>switch</code> 声明一样, 但功能远比 <code>switch</code> 的功能强大<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Coin</span></span> &#123;</span><br><span class="line">  Penny,</span><br><span class="line">  Nickel,</span><br><span class="line">  Dime,</span><br><span class="line">  Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> coin = Coin::Quater;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> money = <span class="hljs-keyword">match</span> coin &#123;</span><br><span class="line">    Coin::Penny =&gt; &#123;</span><br><span class="line">        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Lucky penny!"</span>);</span><br><span class="line">        <span class="hljs-number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Coin::Nickel =&gt; <span class="hljs-number">5</span>,</span><br><span class="line">    Coin::Dime =&gt; <span class="hljs-number">10</span>,</span><br><span class="line">    Coin::Quarter =&gt; <span class="hljs-number">25</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中最常用的用法就是配合 <code>Enum</code> 类型, 带有数据的枚举类通过匹配能够拿到携带的数据, 来提供使用.</p><h3 id="循环体"><a href="#循环体" class="headerlink" title="循环体"></a>循环体</h3><p>Rust 一共提供了三种循环的方式:</p><ul><li><code>loop</code></li><li><code>while</code></li><li><code>for</code></li></ul><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><p>在 Rust 中, 最常见的循环方式就是 <code>loop</code> 语句, 通过 <code>loop</code> 语句产生循环, 然后在循环体中通过 <code>break</code>, <code>continue</code>, <code>return</code>, 这些关键字来控制循环流, 最后达到目的. 不出意外地, <code>loop</code> 依然还是一个表达式, 并且是能够返回值的 _(:зゝ∠)_.</p><ul><li><p>最简单的循环</p><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">loop</span> &#123;</span><br><span class="line">  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"无限循环"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中断的循环</p><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> sum = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> final_sum = <span class="hljs-keyword">loop</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> sum &gt; <span class="hljs-number">10</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">break</span> sum <span class="hljs-comment">// break 这段循环 并返回 sum</span></span><br><span class="line">  &#125;</span><br><span class="line">  sum += <span class="hljs-number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, final_sum);</span><br></pre></td></tr></table></figure></li></ul><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>和 <code>loop</code> 相比, 另外一个用得比较多的循环语句就是 <code>while</code>, <code>while</code> 比较起 <code>loop</code> 来, 明显的区别就是, <code>while</code> 循环的条件语句外置并且 <code>while</code> 语句没有返回值(或者说返回值是一个空元组<code>()</code>), 当循环条件不满足, 循环就直接结束.</p><p>和 <code>loop</code> 一样效果的循环<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> &#123;</span><br><span class="line">  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"我和 loop 一样耶"</span>);</span><br><span class="line">  <span class="hljs-comment">// 可以在循环体中插入 break return 语句作为中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>条件循环<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> counter = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">while</span> counter &lt; <span class="hljs-number">10</span> &#123;</span><br><span class="line">  counter += <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p><code>for</code> 循环相对来说比较特殊, 只能用在那些实现过 <code>iterator</code> 特性的对象上, 没有实现这个特性的对象是没有办法用 <code>for</code> 语句表达的, <code>for</code> 语句是声明, 而不是表达式, 所以也是没办法使用<code>break value</code> 的.<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">11</span> &#123; <span class="hljs-comment">// from..to 产出一个区间为 [from, to) Range 类型的对象, 实现了 iterator </span></span><br><span class="line">  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上就是 Rust 中的控制流, 每一个都提供了非常强大的功能, 实际应用中根据不同的场景应用, 来达到不同的目的.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;/strong&gt; &lt;code&gt;Rust&lt;/code&gt; &lt;code&gt;控制流&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;代码跑与不跑, 跑了之后的结果是什么, 都依赖于控制流, Rust 中的控制流分为两大类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断&lt;/li&gt;
&lt;li&gt;循环&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Rust lang" scheme="https://jeremywu.info/categories/Rust-lang/"/>
    
    
      <category term="Rust" scheme="https://jeremywu.info/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust 的类型系统</title>
    <link href="https://jeremywu.info/2019/03/10/Rust%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"/>
    <id>https://jeremywu.info/2019/03/10/Rust的类型系统/</id>
    <published>2019-03-10T15:20:00.000Z</published>
    <updated>2019-03-31T06:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: </strong> <code>Rust</code> <code>类型系统</code></p><h2 id="Rust-的类型系统"><a href="#Rust-的类型系统" class="headerlink" title="Rust 的类型系统"></a>Rust 的类型系统</h2><p>Rust 是一门静态编译类的语言, 类型系统的设计可以帮助编译器在编译期内就将”容易出错的代码”暴露给编写程序的人. Rust 的类型系统的设计目标是:</p><ul><li>安全性</li><li>效率</li><li>简洁</li></ul><a id="more"></a><p>Rust 的编译器也会根据程序编写者编写的代码自动推断变量的类型, 正因如此, Rust 的程序可以变得更加干净. 当然, 并不能过分依靠这个推断系统, 因为该报错的地方, 编译器依旧会毫不留情地报错.</p><p>关于自动推断类型可以看这个例子:<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 代码摘抄自 Programming Rust 一书</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">build_vector</span></span>() -&gt; <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i16</span>&gt; &#123; <span class="hljs-comment">//&lt;-- 注意返回值</span></span><br><span class="line"><span class="hljs-comment">// let mut v: Vec&lt;i16&gt; = Vec::&lt;i16&gt;::new();</span></span><br><span class="line">  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">Vec</span>::new();</span><br><span class="line"><span class="hljs-comment">// v.push(10i16);</span></span><br><span class="line"><span class="hljs-comment">// v.push(20i16);</span></span><br><span class="line">  v.push(<span class="hljs-number">10</span>);</span><br><span class="line">  v.push(<span class="hljs-number">20</span>);</span><br><span class="line">  v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个例子, 由于函数的返回是 <code>v</code>, 而返回值的类型是 <code>Vec&lt;i16&gt;</code>, 那么自然 <code>v</code> 会被推断为 <code>Vec&lt;i16&gt;</code> 类型. 所以 <code>v.push(item)</code>, <code>item</code> 的类型自然是 <code>i16</code>. 比较注释处的代码会显得更加简洁.</p><h3 id="Rust-的类型种类"><a href="#Rust-的类型种类" class="headerlink" title="Rust 的类型种类"></a>Rust 的类型种类</h3><h4 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h4><table><thead><tr><th style="text-align:center">内存大小 (bits)</th><th style="text-align:center">无符号整数</th><th style="text-align:center">有符号整数</th><th style="text-align:center">浮点数</th></tr></thead><tbody><tr><td style="text-align:center">8</td><td style="text-align:center">u8</td><td style="text-align:center">i8</td><td style="text-align:center">- </td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">u16</td><td style="text-align:center">i16</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">32</td><td style="text-align:center">u32</td><td style="text-align:center">i32</td><td style="text-align:center">f32    </td></tr><tr><td style="text-align:center">64</td><td style="text-align:center">u64</td><td style="text-align:center">i64</td><td style="text-align:center">f64</td></tr><tr><td style="text-align:center">机器字长</td><td style="text-align:center">usize</td><td style="text-align:center">isize</td><td style="text-align:center">-</td></tr></tbody></table><p>注: 机器字长根据 OS 支持的位数来自适应的, 如果你的代码跑在 32 bit 的机器上, 那么机器字长就应该为 32bit, 对应的 <code>uszie</code> 就是 32 位, 但是要注意即使在 32 位的电脑上, 内存里的 <code>usize</code> 和 <code>u32</code> 的内存表示是一样的, 但 <code>usize</code> != <code>u32</code>, 在执行特定操作时, 需要将 <code>usize</code> 通过 <code>usize as u32</code> 强转成 <code>u32</code> 类型.</p><ul><li><strong>无符号整数</strong>每一位都用来表示它的大小. 范围从 0 - 2<sup>size</sup>-1.</li><li><strong>符号整数</strong>在 Rust 中用 <a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E7%AC%A6%E8%99%9F%E6%95%B8%E8%99%95%E7%90%86" target="_blank" rel="noopener">2 的补码</a>来表示, 因此也没有 ±0 的问题存在. 能够表示的范围为 [2<sup>size - 1</sup>, 2 <sup>size - 1</sup> -1]</li><li><p><strong>浮点数</strong>在 Rust 中的表示遵循了 <a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE 754-2008</a> 的单精度和双精度浮点数标准.</p></li><li><p><strong>字符类型</strong>在 Rust 中表示单个有效的 <code>Unicode</code> 字符, 长度为 32-bit, <code>char</code> 只能用来表示一个单独的 Unicode 字符, 以 <code>&#39;独&#39;</code> 形式, 与 <code>str</code> 类型不同在于, <code>char</code> 表示的字符要用 单引号 (<code>&#39;</code>) 来修饰, 而 <code>str</code> 类型使用双引号(<code>&quot;</code>)修饰, 也可以使用 <code>&#39;\u{007F}&#39;</code> 的方式来表示一个 <code>char</code> 类型.</p></li><li><p><strong>布尔类型</strong>在 Rust 中用 <code>true</code> 和 <code>false</code> 表示, 在内存中表示为一个完整的字节 (8-bit), 所以你可以创建一个指向改地址的指针.</p></li></ul><h5 id="最大的数"><a href="#最大的数" class="headerlink" title="最大的数"></a>最大的数</h5><p>Rust 中算数运算如果发生了位溢出会致使整个程序崩溃, Rust 能够表示的最大的有符号整数可以在标准库对应的类型下成员<code>std::itype::MAX</code> 如 <code>std::i32::MAX</code>.</p><h5 id="Byte-类型"><a href="#Byte-类型" class="headerlink" title="Byte 类型"></a>Byte 类型</h5><p>对于很多语言中存在的 <code>byte</code> 类型, 在 Rust 中用 <code>u8</code> 来表示, 当从 socket 和 文件中读取数据时, 都会产出 <code>u8</code> 类型的值.</p><h5 id="整数类型的字面量表示"><a href="#整数类型的字面量表示" class="headerlink" title="整数类型的字面量表示"></a>整数类型的字面量表示</h5><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> suffix = <span class="hljs-number">245u8</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> underscore = <span class="hljs-number">222_222u32</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> bytes_literal = <span class="hljs-number">0b1111_1111</span>; <span class="hljs-comment">// u8</span></span><br><span class="line"><span class="hljs-keyword">let</span> float = <span class="hljs-number">0.5</span>; <span class="hljs-comment">// 自动推断为f64.</span></span><br><span class="line"><span class="hljs-keyword">let</span> octal = <span class="hljs-number">0o53</span>;</span><br></pre></td></tr></table></figure><p>Rust 还提供了一种方式能够方便的将 <a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII</a> 转换成 <code>u8</code> 类型的写法<br><code>let ascii = b&#39;ASCII&#39;;</code>, 这样可以方便快捷地把 ASCII Code 转换成一连串的二进制数.</p><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>Rust 也像 Go, Java 这样的语言一样, 提供了类型之间的转换的方法, 不过关于 Rust 中的类型转换, 此处不做重点介绍, 会专门留一小节来做重点介绍. 但是要注意的是, 与 C, C++ 等语言不同的地方是, Rust 不会对值操作时进行隐式转换, 如类型为 <code>i32</code> 和 <code>i64</code> 的两个变量进行比较时, 尽管 <code>i32</code> 的值永远都是一个有效的 <code>i64</code> 的值, 但因为类型不同, 编译器会在编译期就抛错.</p><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>数组在 Rust 中的表示为 <code>[T;N]</code>, 代表一个含有 N 个 <code>T</code> 类型的集合, 在 Rust 中数组是一个<strong>固定大小</strong>的一个类型, 它在编译期就可以判定所需要内存空间的大小: <code>N * size(T)</code>. 数组不能够添加和删除成员, 但可以改变成员. 数组成员被保存在栈内存中.<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">20u8</span>;<span class="hljs-number">40</span>]; <span class="hljs-comment">// 拥有 40 个 值为 20 的数组</span></span><br><span class="line">a.push(<span class="hljs-number">20u8</span>); <span class="hljs-comment">// no method named `push` found for type `[u8; 40]` in the current scope</span></span><br></pre></td></tr></table></figure></p><h4 id="动态数组类型"><a href="#动态数组类型" class="headerlink" title="动态数组类型"></a>动态数组类型</h4><p>动态数组类型是根数组有着同样作用但内存是在运行时动态分配的, 并且可以动态添加, 删除成员数组, 更改数组的容量大小. 动态数组的成员被保存在堆内存中.</p><h4 id="切片类型"><a href="#切片类型" class="headerlink" title="切片类型"></a>切片类型</h4><p>切片类型是对数组或者动态数组的一个引用, 内存中表现为一个胖指针 (Fat Pointer), 这个胖指针组成如表:<br>字段名     |    描述<br>———-|————<br>pointer   | 指向切片第一个元素的指针<br>number    | 该切片拥有多少个元素</p><h4 id="数组-动态数组-切片的内存模型比较"><a href="#数组-动态数组-切片的内存模型比较" class="headerlink" title="数组, 动态数组, 切片的内存模型比较"></a>数组, 动态数组, 切片的内存模型比较</h4><blockquote><p>图片来自于 Programming Rust 一书</p></blockquote><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串可以被视为一连串的 <code>char</code> 类型的组合, 字符串有两种类型</p><ul><li>str (不可变, 可通过索引访问)</li><li>String (可变, 不可通过索引访问)</li></ul><h5 id="String在内存中的表示"><a href="#String在内存中的表示" class="headerlink" title="String在内存中的表示"></a>String在内存中的表示</h5><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> noodles = <span class="hljs-string">"noodles"</span>.to_string();</span><br><span class="line"><span class="hljs-keyword">let</span> oodles = &amp;noodles[<span class="hljs-number">1</span>..];</span><br><span class="line"><span class="hljs-keyword">let</span> poodles = <span class="hljs-string">" _ "</span>;</span><br></pre></td></tr></table></figure><blockquote><p>% asset_img 字符串内存模型.jpg 字符串内存模型 %}</p><ul><li>以上来自 Programming Rust 一书</li></ul></blockquote><p>String 在内存中是通过运行时动态分配在堆内存上的, 但 <code>String</code> 在堆内存上还是需要有对应的表示的, 实际上, <code>String</code> 类型在堆内存上的表示:</p><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>ptr</td><td>指向堆内存上的第一个字符的内存地址</td></tr><tr><td>capacity</td><td>当前 <code>String</code> 的容量 </td></tr><tr><td>length</td><td>当前 <code>String</code> 的长度</td></tr></tbody></table><p>在 Rust 中, 字符串字面量如: “I am some string” 的类型为 <code>&amp;str</code>, 并且这个变量的生命周期和程序一样长, 当程序启动时该字符串字面量就被创建在常量池中, 当程序结束了之后, 常量池里的该变量也对应销毁. 而动态的 <code>String</code> 用来保存一些动态数据的生命周期并不跟字符串字面量一样长, 这些内存被动态分配.</p><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>Rust 和 C/C++ 一样, 拥有指针类型, 不过 Rust 的指针类型分为引用指针和裸指针.</p><h4 id="引用指针"><a href="#引用指针" class="headerlink" title="引用指针"></a>引用指针</h4><p>通过 <code>&amp;</code> 操作符就可以创建一个指针, 指向对应的变量.<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> a = <span class="hljs-number">20u32</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> ptr = &amp;a;</span><br><span class="line"><span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:p&#125;"</span>, ptr); <span class="hljs-comment">// 0x7fff304b5774</span></span><br></pre></td></tr></table></figure></p><p>但是, 虽然这样就可以直接创建指针, 但是要上例的指针指向的是栈中的变量而不是堆中的变量, 很多时候由于栈的空间有限制, 会倾向于选择在堆上创建变量并建立指针指向这个变量, 如动态数组, 字符串中便有一个保存当前指针的字段.</p><h4 id="盒类型"><a href="#盒类型" class="headerlink" title="盒类型"></a>盒类型</h4><p>通过 Rust 标准库中提供的 <code>Box</code> 类型, 可以非常方便地在堆内存中创建一个变量, 类型为 <code>Box&lt;T&gt;</code>.<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> heap = <span class="hljs-built_in">Box</span>::new(<span class="hljs-number">20u32</span>); <span class="hljs-comment">// Boxed value, 这样就在堆上创建了一个 u32 类型的变量</span></span><br></pre></td></tr></table></figure></p><h3 id="裸指针"><a href="#裸指针" class="headerlink" title="裸指针"></a>裸指针</h3><p>Rust 中的裸指针就和 C/C++ 中的指针类型一样, 拥有同样的功能. 张翁因如此, 野指针由于不可控, 也可能出现空指针的问题.</p><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组在 Rust 中的作用和表现跟其他语言如: Python 中一样, 表示一个有序的”数组”, 和数组不一样, 元组的每一个元素可以拥有不同的类型.<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> tuple = (<span class="hljs-number">1u32</span>, <span class="hljs-number">2u32</span>, <span class="hljs-number">3u32</span>);</span><br><span class="line"><span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, tuple.<span class="hljs-number">0</span>); <span class="hljs-comment">// 用 tuple.index 方式来访问成员</span></span><br><span class="line"><span class="hljs-keyword">let</span> (a, b, c) = tuple; <span class="hljs-comment">// tuple 类的解构</span></span><br></pre></td></tr></table></figure></p><p>在内存中表现为一段连续的不同类型内存的组合, 可以通过元素的位置来访问.<br>并且 tuple 可以通过解构来取得里面的元素.</p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>结构体 (Struct) 跟其他 OOP 中的 class 有些相似, 用来描述一系列类型的组合, 把这些类型聚合在一起, 便成了一个结构体.<br>结构体可以大致划分为两种, 一种就是最普通的结构体, 一种是元组类结构体<br><figure class="highlight rust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;</span><br><span class="line">  x: <span class="hljs-built_in">u32</span>,</span><br><span class="line">  y: <span class="hljs-built_in">u32</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IPv4</span></span>(<span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u8</span>);</span><br></pre></td></tr></table></figure></p><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>Rust 中的枚举类和 C 中的枚举类很相似, 并且有更加强大的功能, Rust 的枚举成员能够包含需要的信息, 并且还可以在枚举类上实现方法.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;/strong&gt; &lt;code&gt;Rust&lt;/code&gt; &lt;code&gt;类型系统&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;Rust-的类型系统&quot;&gt;&lt;a href=&quot;#Rust-的类型系统&quot; class=&quot;headerlink&quot; title=&quot;Rust 的类型系统&quot;&gt;&lt;/a&gt;Rust 的类型系统&lt;/h2&gt;&lt;p&gt;Rust 是一门静态编译类的语言, 类型系统的设计可以帮助编译器在编译期内就将”容易出错的代码”暴露给编写程序的人. Rust 的类型系统的设计目标是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全性&lt;/li&gt;
&lt;li&gt;效率&lt;/li&gt;
&lt;li&gt;简洁&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Rust lang" scheme="https://jeremywu.info/categories/Rust-lang/"/>
    
    
      <category term="Rust" scheme="https://jeremywu.info/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>React源码阅读系列-§2.3-事务机制</title>
    <link href="https://jeremywu.info/2018/08/06/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A72.3-%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/"/>
    <id>https://jeremywu.info/2018/08/06/React源码阅读系列-§2.3-事务机制/</id>
    <published>2018-08-06T13:13:20.000Z</published>
    <updated>2019-03-31T06:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: </strong> <code>transaction</code> <code>batch operation</code></p><h3 id="事务-Transaction-的原理"><a href="#事务-Transaction-的原理" class="headerlink" title="事务(Transaction)的原理"></a>事务(Transaction)的原理</h3><p>在前面有几节中反复提到了React的事务机制(Transaction), 今天就准备来讲一讲这个事务机制到底是怎么个一回事.<br>用一句简单一点的话来形容这个东西就是: 在调用某一个具体的方法之前与之后, 先调用一系列的处理函数, 类似于<code>npm install</code>对应的<code>npm preinstall</code>和<code>npm postinstall</code>, 分别执行于<code>npm install</code>这个脚本的开始之前与完成之后.</p><a id="more"></a><h4 id="用一幅图来说明"><a href="#用一幅图来说明" class="headerlink" title="用一幅图来说明:"></a>用一幅图来说明:</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> *                       wrappers (injected at creation time)</span></span><br><span class="line"><span class="hljs-comment"> *                                      +        +</span></span><br><span class="line"><span class="hljs-comment"> *                                      |        |</span></span><br><span class="line"><span class="hljs-comment"> *                    +-----------------|--------|--------------+</span></span><br><span class="line"><span class="hljs-comment"> *                    |                 v        |              |</span></span><br><span class="line"><span class="hljs-comment"> *                    |      +---------------+   |              |</span></span><br><span class="line"><span class="hljs-comment"> *                    |   +--|    wrapper1   |---|----+         |</span></span><br><span class="line"><span class="hljs-comment"> *                    |   |  +---------------+   v    |         |</span></span><br><span class="line"><span class="hljs-comment"> *                    |   |          +-------------+  |         |</span></span><br><span class="line"><span class="hljs-comment"> *                    |   |     +----|   wrapper2  |--------+   |</span></span><br><span class="line"><span class="hljs-comment"> *                    |   |     |    +-------------+  |     |   |</span></span><br><span class="line"><span class="hljs-comment"> *                    |   |     |                     |     |   |</span></span><br><span class="line"><span class="hljs-comment"> *                    |   v     v                     v     v   | wrapper</span></span><br><span class="line"><span class="hljs-comment"> *                    | +---+ +---+   +---------+   +---+ +---+ | invariants</span></span><br><span class="line"><span class="hljs-comment"> * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained</span></span><br><span class="line"><span class="hljs-comment"> * +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt;</span></span><br><span class="line"><span class="hljs-comment"> *                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="hljs-comment"> *                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="hljs-comment"> *                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="hljs-comment"> *                    | +---+ +---+   +---------+   +---+ +---+ |</span></span><br><span class="line"><span class="hljs-comment"> *                    |  initialize                    close    |</span></span><br><span class="line"><span class="hljs-comment"> *                    +-----------------------------------------+</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br></pre></td></tr></table></figure><p><div class="tip"><br>该图版权属于React开发团队所有.</div></p><p><div><br>在某些框架的源码中其实也依稀可见这种处理的思想, 类似但不仅限于对<code>Array</code>的Native方法的劫持调用, 如<a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a>早期版本当中对<code>Array</code>的处理用来添加函数处理.</div></p><h4 id="事务类的接口定义"><a href="#事务类的接口定义" class="headerlink" title="事务类的接口定义:"></a>事务类的接口定义:</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> TransactionImpl = &#123;</span><br><span class="line">  reinireinitializeTransaction: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 重置wrapper</span></span><br><span class="line">  _isIntransaction: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// transaction调度时标识符</span></span><br><span class="line">  getTransactionWrappers: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Array</span>&lt;TransactionWrapper&gt;; <span class="hljs-comment">// 拿到所有wrapper</span></span><br><span class="line">  isInTransaction: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 得到_isIntransaction属性</span></span><br><span class="line">  perform: &lt;A, B, C, D, E, F, G, T: <span class="hljs-function">(<span class="hljs-params">a: A, b: B, c: C, d: D, e: E, f: F</span>) =&gt;</span> G&gt;</span><br><span class="line">    (method: T, scope: <span class="hljs-built_in">any</span>, a: A, b: B, c: C, d: D, e: E, f: F) =&gt; G; <span class="hljs-comment">// 事务调度 </span></span><br><span class="line">    <span class="hljs-comment">// 在perform方法中先后调用 this.initializeAll(index) 和 this.closeAll(index)</span></span><br><span class="line">  initializeAll: <span class="hljs-function">(<span class="hljs-params">startIndex: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 执行所有wrapper中的initialize方法</span></span><br><span class="line">  closeAll: <span class="hljs-function">(<span class="hljs-params">startIndex: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 执行所有wrapper中的close方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在React整个系统中一共实现了3种事务操作类(服务端渲染和ReactNative不算).</p><ol><li>ReactUpdatesFlushTransaction</li><li>ReactBatchingStrategyTransaction</li><li>ReactReconcileTransaction</li></ol><p>每一种事务类都负责处理对应的操作(下面会说到).</p><p><code>ReactUpdates.batchedUpdates()</code>方法被用来启动整个更新的操作, 然后把这个操作的分配工作交给<code>ReactBatchingUpdateStrategyTransaction</code></p><h4 id="ReactBatchingUpdateStrategyTransaction的Wrapper实现以及功能"><a href="#ReactBatchingUpdateStrategyTransaction的Wrapper实现以及功能" class="headerlink" title="ReactBatchingUpdateStrategyTransaction的Wrapper实现以及功能:"></a>ReactBatchingUpdateStrategyTransaction的Wrapper实现以及功能:</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> TransactionImpl <span class="hljs-keyword">from</span> <span class="hljs-string">'Transaction'</span>;</span><br><span class="line"><span class="hljs-comment">// 定义Wrapper1号</span></span><br><span class="line"><span class="hljs-keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction, <span class="hljs-comment">// 空方法</span></span><br><span class="line">  close: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 标志位置回false</span></span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="hljs-literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 定义Wrapper2号</span></span><br><span class="line"><span class="hljs-keyword">var</span> FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction, <span class="hljs-comment">// 空方法</span></span><br><span class="line">  <span class="hljs-comment">// 更新DOM</span></span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> TRANSACTION_WRAPPERS: <span class="hljs-built_in">Array</span>&lt;TransactionWrapper&gt; = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 当在调用这个transaction.perform方法的时候实际上是这样的:</span></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> *            +----------------------+    +---------------------+        +----------+</span></span><br><span class="line"><span class="hljs-comment"> * perform -&gt; |FLUSH_BATCHED_UPDATES.| -&gt; |REST_BATCHED_UPDATES.| -----&gt; |  method  |</span></span><br><span class="line"><span class="hljs-comment"> *            |      initialize      |    |      initialize     |        |          |</span></span><br><span class="line"><span class="hljs-comment"> *            +----------------------+    +---------------------+        +----------+</span></span><br><span class="line"><span class="hljs-comment"> *                                                                            |</span></span><br><span class="line"><span class="hljs-comment"> *            +----------------------+    +----------------------+            |</span></span><br><span class="line"><span class="hljs-comment"> *            |REST_BATCHED_UPDATES. |    |FLUSH_BATCHED_UPDATES.|            |</span></span><br><span class="line"><span class="hljs-comment"> *            |        close         |    |        close         | &lt;----------+</span></span><br><span class="line"><span class="hljs-comment"> *            +----------------------+    +----------------------+</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br></pre></td></tr></table></figure><p><code>ReactUpdates.flushBatchedUpdates</code>调用<code>ReactUpdatesFlushTransaction.perform(runBatchedUpdates)方法</code>👇.</p><h4 id="ReactUpdatesFlushTransaction的实现以及功能"><a href="#ReactUpdatesFlushTransaction的实现以及功能" class="headerlink" title="ReactUpdatesFlushTransaction的实现以及功能"></a>ReactUpdatesFlushTransaction的实现以及功能</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Wrapper1号定义</span></span><br><span class="line"><span class="hljs-keyword">var</span> NESTED_UPDATES = &#123;</span><br><span class="line">  initialize: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.dirtyComponentsLength = dirtyComponents.length;</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dirtyComponentsLength !== dirtyComponents.length) &#123;</span><br><span class="line">      <span class="hljs-comment">// 处理当 A的update过程中调用了B的setState方法的情况</span></span><br><span class="line">      dirtyComponents.splice(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.dirtyComponentsLength);</span><br><span class="line">      flushBatchedUpdates();</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      dirtyComponents.length = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// Wrapper2号定义</span></span><br><span class="line"><span class="hljs-keyword">var</span> UPDATE_QUEUEING = &#123;</span><br><span class="line">  initialize: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.callbackQueue.reset();</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.callbackQueue.notifyAll();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">ReactUpdatesFlushTransaction.prototype.perform = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method, scope, a</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 调用ReactReconcileTransaction去调用runBatchedUpdates方法</span></span><br><span class="line">  <span class="hljs-keyword">return</span> Transaction.perform.call(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.reconcileTransaction.perform, <span class="hljs-keyword">this</span>.reconcileTransaction, method, scope, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就到了我们执行更新操作的那位选手<code>ReactReconcileTransaction</code></p><h4 id="ReactReconcileTransaction的实现以及功能"><a href="#ReactReconcileTransaction的实现以及功能" class="headerlink" title="ReactReconcileTransaction的实现以及功能"></a>ReactReconcileTransaction的实现以及功能</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> SELECTION_RESTORATION = &#123;</span><br><span class="line">  initialize: ReactInputSelection.getSelectionInformation,</span><br><span class="line">  close: ReactInputSelection.restoreSelection,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> EVENT_SUPPRESSION = &#123;</span><br><span class="line">  initialize: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> currentlyEnabled = ReactBrowserEventEmitter.isEnabled();</span><br><span class="line">    ReactBrowserEventEmitter.setEnabled(<span class="hljs-literal">false</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> currentlyEnabled;</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">previouslyEnabled</span>) </span>&#123;</span><br><span class="line">    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> ON_DOM_READY_QUEUEING = &#123;</span><br><span class="line">  initialize: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.reactMountReady.reset();</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.reactMountReady.notifyAll();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> TRANSACTION_WRAPPERS = [</span><br><span class="line">  SELECTION_RESTORATION,</span><br><span class="line">  EVENT_SUPPRESSION,</span><br><span class="line">  ON_DOM_READY_QUEUEING,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>至此整个事务调用结束 由batchingTransaction -&gt; FlushTransaction -&gt; ReconcileTransaction去调用了<code>ReactUpdates.runBatchedUpdates</code>方法, 然后分别处理了<code>callback</code>, <code>DOM事件</code>等一系列事务调用.</p><h4 id="下节预告-React中的事件机制"><a href="#下节预告-React中的事件机制" class="headerlink" title="下节预告: React中的事件机制."></a>下节预告: React中的事件机制.</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;/strong&gt; &lt;code&gt;transaction&lt;/code&gt; &lt;code&gt;batch operation&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;事务-Transaction-的原理&quot;&gt;&lt;a href=&quot;#事务-Transaction-的原理&quot; class=&quot;headerlink&quot; title=&quot;事务(Transaction)的原理&quot;&gt;&lt;/a&gt;事务(Transaction)的原理&lt;/h3&gt;&lt;p&gt;在前面有几节中反复提到了React的事务机制(Transaction), 今天就准备来讲一讲这个事务机制到底是怎么个一回事.&lt;br&gt;用一句简单一点的话来形容这个东西就是: 在调用某一个具体的方法之前与之后, 先调用一系列的处理函数, 类似于&lt;code&gt;npm install&lt;/code&gt;对应的&lt;code&gt;npm preinstall&lt;/code&gt;和&lt;code&gt;npm postinstall&lt;/code&gt;, 分别执行于&lt;code&gt;npm install&lt;/code&gt;这个脚本的开始之前与完成之后.&lt;/p&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>React源码阅读系列-§2.2-从虚拟DOM到真实DOM</title>
    <link href="https://jeremywu.info/2018/08/04/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A72.2-%E4%BB%8E%E8%99%9A%E6%8B%9FDOM%E5%88%B0%E7%9C%9F%E5%AE%9EDOM/"/>
    <id>https://jeremywu.info/2018/08/04/React源码阅读系列-§2.2-从虚拟DOM到真实DOM/</id>
    <published>2018-08-04T15:20:00.000Z</published>
    <updated>2019-03-31T06:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: </strong> <code>虚拟DOM</code> <code>真实DOM</code></p><h3 id="从虚拟DOM节点链接到真实的DOM节点"><a href="#从虚拟DOM节点链接到真实的DOM节点" class="headerlink" title="从虚拟DOM节点链接到真实的DOM节点"></a>从虚拟DOM节点链接到真实的DOM节点</h3><p>当经过挂载/更新, React自己管理的那份DOM节点都会被更新, 无论是从无到有亦或是从旧到新, 都需要经历的从虚拟的DOM链接到真实的DOM当中然后才能被浏览器表现在页面上.<br>那么这一部分功能到底是怎么完成的呢? 从<a href="/2018/07/26/React源码阅读系列-§2.1-生命周期过程详解/">上一节</a>中了解到了React虚拟DOM渲染出来的DOM片段到底长什么样, 接下来就要知道的是这个东西到底是怎么被渲染进入浏览器的DOM对象当中的.</p><a id="more"></a><h4 id="ReactMount-mountImageIntoNode"><a href="#ReactMount-mountImageIntoNode" class="headerlink" title="ReactMount._mountImageIntoNode"></a>ReactMount._mountImageIntoNode</h4><p>此处用挂载时的函数方法来举例, 更新的挂载操作类似, 但我们只关注更新操作的更新策略.</p><p><code>ReactMount.mountComponentIntoNode</code>方法的最后通过调用<code>ReactMount._mountImageIntoNode</code>来把渲染好的DOM片段链接到DOM当中去<br><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ReactMount._mountImageIntoNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    markup,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    container,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    instance,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    shouldReuseMarkup,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    transaction,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">  </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// ... 省略掉一些ServerRendering的处理代码以及开发阶段报错的代码</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (transaction.useCreateElement) &#123;</span><br><span class="line">      <span class="hljs-keyword">while</span> (container.lastChild) &#123;</span><br><span class="line">        container.removeChild(container.lastChild);</span><br><span class="line">      &#125;</span><br><span class="line">      DOMLazyTree.insertTreeBefore(container, markup, <span class="hljs-literal">null</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      setInnerHTML(container, markup);</span><br><span class="line">      ReactDOMComponentTree.precacheNode(instance, container.firstChild);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在这个方法里通过<code>DOMLazyTree.insertTreeBefore</code>方法, 把渲染好的DOM片段塞到了真实的DOM里<br><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 此处方法经过一些特殊处理... 来处理M$的兼容性</span></span><br><span class="line"><span class="hljs-keyword">var</span> insertTreeBefore = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">  parentNode,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">  tree,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">  referenceNode,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (</span><br><span class="line">    tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE ||</span><br><span class="line">    (tree.node.nodeType === ELEMENT_NODE_TYPE &amp;&amp;</span><br><span class="line">      tree.node.nodeName.toLowerCase() === <span class="hljs-string">'object'</span> &amp;&amp;</span><br><span class="line">      (tree.node.namespaceURI == <span class="hljs-literal">null</span> ||</span><br><span class="line">        tree.node.namespaceURI === DOMNamespaces.html))</span><br><span class="line">  ) &#123;</span><br><span class="line">    insertTreeChildren(tree);</span><br><span class="line">    parentNode.insertBefore(tree.node, referenceNode);</span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    parentNode.insertBefore(tree.node, referenceNode);</span><br><span class="line">    insertTreeChildren(tree);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>parentNode.insertBefore</code>方法就是DOM方法<a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore" target="_blank" rel="noopener">Node.insertBefre</a>方法. 到这边结束之后渲染好的DOM片段就被正式挂载进入了DOM当中.</p><h4 id="下节预告-React中的事务处理"><a href="#下节预告-React中的事务处理" class="headerlink" title="下节预告:  React中的事务处理."></a>下节预告:  React中的事务处理.</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;/strong&gt; &lt;code&gt;虚拟DOM&lt;/code&gt; &lt;code&gt;真实DOM&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;从虚拟DOM节点链接到真实的DOM节点&quot;&gt;&lt;a href=&quot;#从虚拟DOM节点链接到真实的DOM节点&quot; class=&quot;headerlink&quot; title=&quot;从虚拟DOM节点链接到真实的DOM节点&quot;&gt;&lt;/a&gt;从虚拟DOM节点链接到真实的DOM节点&lt;/h3&gt;&lt;p&gt;当经过挂载/更新, React自己管理的那份DOM节点都会被更新, 无论是从无到有亦或是从旧到新, 都需要经历的从虚拟的DOM链接到真实的DOM当中然后才能被浏览器表现在页面上.&lt;br&gt;那么这一部分功能到底是怎么完成的呢? 从&lt;a href=&quot;/2018/07/26/React源码阅读系列-§2.1-生命周期过程详解/&quot;&gt;上一节&lt;/a&gt;中了解到了React虚拟DOM渲染出来的DOM片段到底长什么样, 接下来就要知道的是这个东西到底是怎么被渲染进入浏览器的DOM对象当中的.&lt;/p&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>React源码阅读系列-§2.1-生命周期过程详解</title>
    <link href="https://jeremywu.info/2018/07/26/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A72.1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jeremywu.info/2018/07/26/React源码阅读系列-§2.1-生命周期过程详解/</id>
    <published>2018-07-26T13:18:31.000Z</published>
    <updated>2019-03-31T06:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: </strong> <code>生命周期</code> <code>钩子函数</code></p><p>在<a href="/2018/07/17/React源码阅读系列-§1.1-生命周期-Lifecycle">§1.1节</a>大概的了解了React的生命周期以及在各个阶段的生命周期钩子函数的调用.</p><p>在本节主要详细讲解各个生命周期函数, 以及一些对性能上能够产生优化的细节.</p><a id="more"></a><div class="tip"><br>以下面内容仅适用于用户自定义组件, 无状态组件不经历大部分钩子函数的调用.<br></div><hr><h3 id="生命周期的阶段"><a href="#生命周期的阶段" class="headerlink" title="生命周期的阶段"></a>生命周期的阶段</h3><p><strong>每一个</strong>React的组件都会经历它的生命周期.</p><h4 id="1-挂载阶段-Mounting-Period"><a href="#1-挂载阶段-Mounting-Period" class="headerlink" title="1. 挂载阶段 (Mounting Period)"></a>1. 挂载阶段 (Mounting Period)</h4><ul><li><p>1) 组件被实例化</p><p>在之前的<a href="/2018/07/21/React源码阅读系列-§1.4-来人-给我new一下">§1.3节</a>讲到每一个<code>CustomComponent</code>都是被<code>CompositeComponentWrapper</code>给包裹了起来, 实际被实例化的地方是在<code>ReactCompositeComponent._constructComponentWithoutOwner</code>方法中.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CustomComponent(publicProps, publicContext, updateQueue);</span><br></pre></td></tr></table></figure><p>此处就是所有的组件的构造函数被调用的地方. 为的是把实例存在<code>ReactInstanceMap</code>中, 方便使用, 例如<code>React.findDOMNode()</code>方法就通过这个<code>ReactInstanceMap</code>拿到了实例通过实例在对应的<code>ReactDOMTree</code>中找到了对应的DOM节点.</p></li><li><p>2) componentWillMount的调用</p><p>无状态组件是不经历这一步的, 如果用户有添加<code>componentWillMount</code>这个方法, 那么该方法将会在<code>performInitialMount</code>方法内被调用.</p></li><li><p>3) render的调用时机</p><p>render被调用有两种情况. </p><ol><li><p>第一种情况是如果组件本身是无状态组件那么在</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> renderedElement;</span><br><span class="line"><span class="hljs-comment">// 如果是无状态的组件返回false, 否则返回true.</span></span><br><span class="line"><span class="hljs-keyword">var</span> doConstruct = shouldConstruct(Component);</span><br><span class="line"><span class="hljs-keyword">var</span> inst = <span class="hljs-keyword">this</span>._constructComponent(</span><br><span class="line">    doConstruct, <span class="hljs-comment">// false</span></span><br><span class="line">    publicProps,</span><br><span class="line">    publicContext,</span><br><span class="line">    updateQueue,</span><br><span class="line">  );</span><br><span class="line"><span class="hljs-keyword">if</span> (!doConstruct &amp;&amp; (inst == <span class="hljs-literal">null</span> || inst.render == <span class="hljs-literal">null</span>)) &#123;</span><br><span class="line">  renderedElement = inst; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法内部这个组件的<code>render</code>方法就可以看做已经被调用过了, 因为本身就只是一个函数类型的组件.</p></li><li>第二种是如果并非无状态组件, 那么<code>render</code>的调用发生在<code>performInitialMount</code>方法中<figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 在不满足上面的条件时, renderedElement自然为undefined.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (renderedElement === <span class="hljs-literal">undefined</span>) &#123;</span><br><span class="line">    renderedElement = <span class="hljs-keyword">this</span>._renderValidatedComponent(); <span class="hljs-comment">// 此处调用inst.render()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里的<code>renderedElement</code>就是在第<a href="/2018/07/18/React源码阅读系列-§1.2先有节点后有天%20ReactCreateElement">§1.2节</a>通过<code>render()</code>方法返回出来的<code>React.createElement()</code>的结构. 是一个<code>ReactElement</code>的类实例. 然后会被用来通过进行一个递归调用, 所有的自定义组件都会被转换到<code>ReactDOMComponent</code>, 然后通过<code>ReactDOMComponent.mountComponent</code>方法返回一段<code>ReactNode</code>的对象实例</p><p>最后调用<code>render</code>方法之后得到的markup类似于:</p><img src="/2018/07/26/React源码阅读系列-§2.1-生命周期过程详解/markup.png" title="markup"><p>从<code>ReactCompositeComponent</code>到<code>ReactDOMComponent</code>, 然后再被转换成为真实的<code>DOM</code>节点<strong>(划重点: DOM节点内只有字符串)</strong>. 在<code>ReactDOMComponent</code>当中有一个比较重要的方法: </p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">this</span>._createInitialChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">transaction, props, context, lazyTree</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> innerHTML = props.dangerouslySetInnerHTML;</span><br><span class="line">  <span class="hljs-keyword">if</span> (innerHTML != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (innerHTML.__html != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">      DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> contentToUse = CONTENT_TYPES[<span class="hljs-keyword">typeof</span> props.children]</span><br><span class="line">      ? props.children</span><br><span class="line">      : <span class="hljs-literal">null</span>;</span><br><span class="line">    <span class="hljs-keyword">var</span> childrenToUse = contentToUse != <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : props.children;</span><br><span class="line">    <span class="hljs-keyword">if</span> (contentToUse != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (contentToUse !== <span class="hljs-string">''</span>) &#123;</span><br><span class="line">        DOMLazyTree.queueText(lazyTree, contentToUse);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childrenToUse != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">var</span> mountImages = <span class="hljs-keyword">this</span>.mountChildren(</span><br><span class="line">        childrenToUse,</span><br><span class="line">        transaction,</span><br><span class="line">        context,</span><br><span class="line">      );</span><br><span class="line">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; mountImages.length; i++) &#123;</span><br><span class="line">        DOMLazyTree.queueChild(lazyTree, mountImages[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的解释一下这段方法:</p><ol><li>首先先去判断了是否有强行塞入<code>innerHTML</code>的这种做法, 很显然官方本身是不推荐用户这样去使用, 但是在某一些的特定场景下, 必须要用到这种方法.<ul><li><code>true</code>, 就把<code>__html</code>作为当前节点的<code>innerHTML</code>.</li><li><code>false</code>, 继续进行下一步.</li></ul></li><li>接着去判断当前的<code>children</code>是否是<code>CONTENT_TYPES</code>这个枚举类的成员.<ul><li><code>true</code>, 那就把<code>children</code>塞给当前的节点作为<code>innerHTML</code>.</li><li><code>false</code>, 那么就证明现在的这个<code>children</code>并非是一个<code>DOM</code>节点而是一个自定义的组件. 那就继续调用<code>instantiateReactComponent</code>方法来实例化<code>children</code>直到所有的子节点被创建完成.<div class="tip">注意: 此处是一个递归调用的过程</div></li></ul></li></ol><p>到这个地方, 基本<code>render</code>方法的调用就结束了, 调用完成的结果就是上面图例的<code>markup</code>对象.</p></li></ul><ul><li><p>4) componentDidMount的调用: </p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (inst.componentDidMount) &#123;</span><br><span class="line">  transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里React的开发者们很聪明的采用了一个队列的形式, 采用批处理的方式来调用<code>componentDidMount</code>的方法.<br>到这个地方, React的挂载阶段基本就已经结束了. 对于<code>事务处理</code>以及<code>事件机制</code>还有<code>对象池</code>的概念, 到后面会再说到.</p></li></ul><h4 id="2-存在阶段"><a href="#2-存在阶段" class="headerlink" title="2. 存在阶段"></a>2. 存在阶段</h4><p>  存在阶段主要对应的主要是对浏览器事件的一个响应, 因为用户操作而触发的一系列浏览器事件.<br>  接下来的更新都是交互后产生的更新操作, 浏览器响应相应的事件最后被setState或改变props触发更新. (setState会在后面章节进行详细的介绍).</p><ol><li><p>主播再不更新我就退订! updateComponent (这里以ReactCompositeComponent <strong>[自定义组件]</strong>为例)</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> updateComponent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    transaction,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    prevParentElement,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    nextParentElement,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    prevUnmaskedContext,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    nextUnmaskedContext,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">  </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> inst = <span class="hljs-keyword">this</span>._instance;</span><br><span class="line">    invariant( <span class="hljs-comment">// 如果对已经被卸载掉的节点调用这个方法则抛异常</span></span><br><span class="line">      inst != <span class="hljs-literal">null</span>,</span><br><span class="line">      <span class="hljs-string">'Attempted to update component `%s` that has already been unmounted '</span> +</span><br><span class="line">        <span class="hljs-string">'(or failed to mount).'</span>,</span><br><span class="line">      <span class="hljs-keyword">this</span>.getName() || <span class="hljs-string">'ReactCompositeComponent'</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="hljs-keyword">var</span> willReceive = <span class="hljs-literal">false</span>;</span><br><span class="line">    <span class="hljs-keyword">var</span> nextContext;</span><br><span class="line">    <span class="hljs-comment">// 检查context上的值是否一致</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._context === nextUnmaskedContext) &#123;</span><br><span class="line">      nextContext = inst.context;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      nextContext = <span class="hljs-keyword">this</span>._processContext(nextUnmaskedContext);</span><br><span class="line">      willReceive = <span class="hljs-literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">var</span> prevProps = prevParentElement.props;</span><br><span class="line">    <span class="hljs-keyword">var</span> nextProps = nextParentElement.props;</span><br><span class="line">    <span class="hljs-comment">// 对比前后的Element是否相同</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (prevParentElement !== nextParentElement) &#123;</span><br><span class="line">      <span class="hljs-comment">// 更新标识符设置为true</span></span><br><span class="line">      willReceive = <span class="hljs-literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123;</span><br><span class="line">      inst.componentWillReceiveProps(nextProps, nextContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">var</span> nextState = <span class="hljs-keyword">this</span>._processPendingState(nextProps, nextContext); <span class="hljs-comment">// 拿到下一个时间的state</span></span><br><span class="line">    <span class="hljs-keyword">var</span> shouldUpdate = <span class="hljs-literal">true</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._pendingForceUpdate) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (inst.shouldComponentUpdate) &#123;</span><br><span class="line">          shouldUpdate = inst.shouldComponentUpdate(<span class="hljs-comment">// &lt;- 实例shouldComponentUpdate钩子调用</span></span><br><span class="line">            nextProps,</span><br><span class="line">            nextState,</span><br><span class="line">            nextContext,</span><br><span class="line">          );</span><br><span class="line">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// 处理一个PureComponent的条件, 关于PureComponent与Component的对比</span></span><br><span class="line">        <span class="hljs-comment">// 可以在给到的几个链接里多看看这里就不多做解释</span></span><br><span class="line">        <span class="hljs-comment">// https://60devs.com/pure-component-in-react.html</span></span><br><span class="line">        <span class="hljs-comment">// https://stackoverflow.com/questions/41340697/react-component-vs-react-purecomponent</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._compositeType === CompositeTypes.PureClass) &#123;</span><br><span class="line">          shouldUpdate =</span><br><span class="line">            !shallowEqual(prevProps, nextProps) ||</span><br><span class="line">            !shallowEqual(inst.state, nextState);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">this</span>._updateBatchNumber = <span class="hljs-literal">null</span>;</span><br><span class="line">    <span class="hljs-comment">// 从这里可以看到shouldUpdate这个值默认都是被设置为true的, 所以在性能优化的时候, 可以考虑使用</span></span><br><span class="line">    <span class="hljs-comment">// shouldComponentUpdate这个钩子函数来控制一下重绘的组件的数量来达到减少重绘调用优化性能的目的</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (shouldUpdate) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>._pendingForceUpdate = <span class="hljs-literal">false</span>;</span><br><span class="line">      <span class="hljs-comment">// 传递新的属性, 状态, 上下文进行更新</span></span><br><span class="line">      <span class="hljs-keyword">this</span>._performComponentUpdate(</span><br><span class="line">        nextParentElement,</span><br><span class="line">        nextProps,</span><br><span class="line">        nextState,</span><br><span class="line">        nextContext,</span><br><span class="line">        transaction,</span><br><span class="line">        nextUnmaskedContext,</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>._currentElement = nextParentElement;</span><br><span class="line">      <span class="hljs-keyword">this</span>._context = nextUnmaskedContext;</span><br><span class="line">      inst.props = nextProps;</span><br><span class="line">      inst.state = nextState;</span><br><span class="line">      inst.context = nextContext;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在判断完需要更新这个结果之后, 就要进行接下来的<code>performUpdate</code>操作.</p></li><li><p>开始你的表演 performUpdate</p><p>performUpdate顾名思义就是要进行实际的更新操作了, 更新操作实际上大致与初始的挂载操作一致. 代码走你!</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">_performComponentUpdate: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">  nextElement,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">  nextProps,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">  nextState,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">  nextContext,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">  transaction,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">  unmaskedContext,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> inst = <span class="hljs-keyword">this</span>._instance;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">var</span> hasComponentDidUpdate = <span class="hljs-built_in">Boolean</span>(inst.componentDidUpdate);</span><br><span class="line">  <span class="hljs-keyword">var</span> prevProps;</span><br><span class="line">  <span class="hljs-keyword">var</span> prevState;</span><br><span class="line">  <span class="hljs-keyword">var</span> prevContext;</span><br><span class="line">  <span class="hljs-keyword">if</span> (hasComponentDidUpdate) &#123;</span><br><span class="line">    prevProps = inst.props;</span><br><span class="line">    prevState = inst.state;</span><br><span class="line">    prevContext = inst.context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (inst.componentWillUpdate) &#123;</span><br><span class="line">    <span class="hljs-comment">// 👇 willUpdate 钩子函数调用</span></span><br><span class="line">    inst.componentWillUpdate(nextProps, nextState, nextContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">this</span>._currentElement = nextElement;</span><br><span class="line">  <span class="hljs-keyword">this</span>._context = unmaskedContext;</span><br><span class="line">  inst.props = nextProps;</span><br><span class="line">  inst.state = nextState;</span><br><span class="line">  inst.context = nextContext;</span><br><span class="line">  <span class="hljs-comment">// 把更新传递到DOM上去 这边的更新跟挂载时的操作很相似 所以就不做展开了.</span></span><br><span class="line">  <span class="hljs-keyword">this</span>._updateRenderedComponent(transaction, unmaskedContext);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (hasComponentDidUpdate) &#123;</span><br><span class="line">    <span class="hljs-comment">// 设置好最后一个更新的钩子函数, 在事务操作结束之后调用</span></span><br><span class="line">    transaction</span><br><span class="line">      .getReactMountReady()</span><br><span class="line">      .enqueue(</span><br><span class="line">        inst.componentDidUpdate.bind(</span><br><span class="line">          inst,</span><br><span class="line">          prevProps,</span><br><span class="line">          prevState,</span><br><span class="line">          prevContext,</span><br><span class="line">        ),</span><br><span class="line">        inst,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于在最后, 怎么把这些节点给反映到到DOM上去的呢? 请看下回分解.</p></li></ol><h3 id="下节预告-从虚拟DOM到真实的DOM"><a href="#下节预告-从虚拟DOM到真实的DOM" class="headerlink" title="下节预告: 从虚拟DOM到真实的DOM."></a>下节预告: 从虚拟DOM到真实的DOM.</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;/strong&gt; &lt;code&gt;生命周期&lt;/code&gt; &lt;code&gt;钩子函数&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;/2018/07/17/React源码阅读系列-§1.1-生命周期-Lifecycle&quot;&gt;§1.1节&lt;/a&gt;大概的了解了React的生命周期以及在各个阶段的生命周期钩子函数的调用.&lt;/p&gt;
&lt;p&gt;在本节主要详细讲解各个生命周期函数, 以及一些对性能上能够产生优化的细节.&lt;/p&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>React源码阅读系列-§1.5-ReactDOM.render干了啥</title>
    <link href="https://jeremywu.info/2018/07/22/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A71.5-ReactDOM-render%E5%B9%B2%E4%BA%86%E5%95%A5/"/>
    <id>https://jeremywu.info/2018/07/22/React源码阅读系列-§1.5-ReactDOM-render干了啥/</id>
    <published>2018-07-22T14:01:06.000Z</published>
    <updated>2019-03-31T06:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: </strong> <code>ReactDOM.render</code> <code>调用栈</code></p><p>React应用的启动可谓是相当简单了, 无需过多的配置, 只需要三行代码便可以启动</p><figure class="highlight jsx hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> &#123;render&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;</span><br><span class="line">render((<span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>启动!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>), <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#root'</span>));</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>ReactDOM.render</code>方法一共接受三个参数:<br><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nextElement, container, callback</span>) </span>&#123;...&#125;;</span><br></pre></td></tr></table></figure></p><p>第一个参数为需要渲染的<code>ReactElement</code>;<br>第二个参数是用来挂载渲染好的DOM节点的<code>Container</code>;<br>第三个参数为一个可选参数,用来接受一个在该方法结束之后被调用的一个<code>Function</code>;</p><p>结合上一些代码来了解一下, 该方法被调用时到底经过了哪一些过程.</p><hr><h3 id="ReactDOM-render-的调用栈"><a href="#ReactDOM-render-的调用栈" class="headerlink" title="ReactDOM.render()的调用栈"></a><code>ReactDOM.render()的调用栈</code></h3><p>为了更好的能够理解这一章的内容, 上一篇已经通过了<code>ReactCompositeComponent</code>做了一轮铺垫, 在有了上一篇的知识的基础上, 本篇内容的复杂度将会大大降低.</p><div class="tip"><br>所有内容均建立在没有启动<code>ServerSideRendering</code>的情况之下.<br></div><h4 id="通过文字来描述"><a href="#通过文字来描述" class="headerlink" title="通过文字来描述:"></a>通过文字来描述:</h4><ol><li><code>render</code>方法首先会调用<code>_renderSubtreeIntoContainer</code>来启动调用过程, 该方法会调用<code>_renderNewRootComponent</code>方法. 并且会调用<code>render</code>传入的callback方法.</li><li><code>_renderNewRootComponent</code>会调用<code>instantiateReactComponent()</code>方法来实例化被传入的组件. 然后得到对应的组件树.</li><li>把得到的组件树通过<code>ReactUpdates.batchedUpdates</code>更新到DOM中.<br>i. <code>ReactUpdates.batchedUpdates</code>会通过调用<code>batchingStrategy.batchedUpdates</code>来调用<code>batchedMountComponentIntoNode</code>方法. 这里有关于<strong><u>ReactTransaction</u></strong>的概念, 在后面一章里面会讲到.<br>ii. 这边需要关注的方法就是<code>batchedMountComponentIntoNode</code>方法.</li><li><code>batchedMountComponentIntoNode</code>调用<code>mountComponentIntoNode</code>, 然后紧接着<code>ReactReconciler.mountComponen</code>被调用. 到这里开始就是上一章讲过的那一部分内容了. 实例内部的生命周期被调用, 然后返回了对应的DOM结构.</li><li>返回的DOM结构被通过<code>ReactMount._mountImageIntoNode</code>方法挂载进入真正的DOM中.</li><li>至此, 整个调用过程结束.</li></ol><h4 id="通过一张流程图来描述"><a href="#通过一张流程图来描述" class="headerlink" title="通过一张流程图来描述:"></a>通过一张流程图来描述:</h4><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">↓: 表示调用</span><br><span class="line"><span class="hljs-code">            开始</span></span><br><span class="line"><span class="hljs-code">             ↓</span></span><br><span class="line">   ReactMount.render</span><br><span class="line"><span class="hljs-code">             ↓</span></span><br><span class="line">ReactMount._renderSubtreeIntoContainer</span><br><span class="line"><span class="hljs-code">             ↓</span></span><br><span class="line">ReactMount._renderNewRootComponent // 触发创建真实DOM节点</span><br><span class="line"><span class="hljs-code">             ↓</span></span><br><span class="line">instantiateReactComponent  // 创建真实DOM</span><br><span class="line"><span class="hljs-code">             ↓</span></span><br><span class="line">batchedMountComponentIntoNode</span><br><span class="line"><span class="hljs-code">             ↓</span></span><br><span class="line">mountComponentIntoNode</span><br><span class="line"><span class="hljs-code">             ↓ </span></span><br><span class="line">ReactReconciler.mountComponent</span><br><span class="line"><span class="hljs-code">             ↓</span></span><br><span class="line">ReactCompositeComponent.mountComponent</span><br><span class="line"><span class="hljs-code">             ↓</span></span><br><span class="line">ReactCompositeComponent.performInitialMount</span><br><span class="line"><span class="hljs-code">             ↓</span></span><br><span class="line">ReactMount._mountImageIntoNode     </span><br><span class="line"><span class="hljs-code">             ↓\</span></span><br><span class="line"><span class="hljs-code">        setInnerHTML |----  通过根节点挂载</span></span><br><span class="line"><span class="hljs-code">             ↓/</span></span><br><span class="line">ReactDOMComponentTree.precacheNode    // 保存virtualDOM </span><br><span class="line"><span class="hljs-code">             ↓</span></span><br><span class="line"><span class="hljs-code">            结束</span></span><br></pre></td></tr></table></figure><h4 id="通过一张关系图来描述"><a href="#通过一张关系图来描述" class="headerlink" title="通过一张关系图来描述"></a>通过一张关系图来描述</h4><img src="/2018/07/22/React源码阅读系列-§1.5-ReactDOM-render干了啥/render.png" title="render"><hr><h3 id="小结-amp-预告"><a href="#小结-amp-预告" class="headerlink" title="小结&amp;预告:"></a>小结&amp;预告:</h3><p>通过了解框架中封装的方法内部的调用实现, 可以更直观的去了解框架, 能够在后续的工作当中让自己写出来性能更加高的代码, 并且对整体应用能有所规划. </p><p><strong>下期预告: React生命周期的具体分析.</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;/strong&gt; &lt;code&gt;ReactDOM.render&lt;/code&gt; &lt;code&gt;调用栈&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;React应用的启动可谓是相当简单了, 无需过多的配置, 只需要三行代码便可以启动&lt;/p&gt;
&lt;figure class=&quot;highlight jsx hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; React &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;react&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; &amp;#123;render&amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;react-dom&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;render((&lt;span class=&quot;hljs-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;启动!&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;), &lt;span class=&quot;hljs-built_in&quot;&gt;document&lt;/span&gt;.querySelector(&lt;span class=&quot;hljs-string&quot;&gt;&#39;#root&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>React源码阅读系列-§1.4-来人, 给我new一下</title>
    <link href="https://jeremywu.info/2018/07/21/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A71.4-%E6%9D%A5%E4%BA%BA-%E7%BB%99%E6%88%91new%E4%B8%80%E4%B8%8B/"/>
    <id>https://jeremywu.info/2018/07/21/React源码阅读系列-§1.4-来人-给我new一下/</id>
    <published>2018-07-21T13:22:56.000Z</published>
    <updated>2019-03-31T06:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: </strong> <code>ReactCompositeComponent</code> <code>instantiate</code></p><h3 id="让我们先实例化一个组件"><a href="#让我们先实例化一个组件" class="headerlink" title="让我们先实例化一个组件"></a>让我们先实例化一个组件</h3><p><a href="/2018/07/20/React源码阅读系列-§1.3先给我整一个Component/">上一章</a>讲到了, React的<code>Component</code>种类, 但没讲到用户自己写的<code>CustomComponent</code>是怎么被实例化的. 在后面的章节会介绍到关于应用启动的过程到底发生了哪些事情, 在这边就先简单的做一个铺垫. 主要关注在<code>CustomComponent</code>的实例化过程.</p><a id="more"></a><p>当我们调用<code>React.render(...)</code>方法的时候, 会调用<a href="https://github.com/facebook/react/blob/v15.6.2/src/renderers/shared/stack/reconciler/instantiateReactComponent.js" target="_blank" rel="noopener">ReactMount.js</a>中的<code>instantiateReactComponent</code>方法, 该方法中涉及到实例化一个<code>CustomComponent</code>的代码为:<br><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instantiateReactComponent</span>(<span class="hljs-params">node, shouldHaveDebugID</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> instance;</span><br><span class="line">  <span class="hljs-keyword">var</span> element = node;</span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> element.type === <span class="hljs-string">'string'</span>) &#123;</span><br><span class="line">        instance = ReactHostComponent.createInternalComponent(element);</span><br><span class="line">      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isInternalComponentType(element.type)) &#123;</span><br><span class="line">        instance = <span class="hljs-keyword">new</span> element.type(element);</span><br><span class="line">        <span class="hljs-keyword">if</span> (!instance.getHostNode) &#123;</span><br><span class="line">          instance.getHostNode = instance.getNativeNode;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        instance = <span class="hljs-keyword">new</span> ReactCompositeComponentWrapper(element);</span><br><span class="line">      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> node === <span class="hljs-string">'number'</span>) &#123;</span><br><span class="line">        instance = ReactHostComponent.createInstanceForText(node);</span><br><span class="line">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Encountered invalid React node of type "</span> + <span class="hljs-keyword">typeof</span> node );</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>关键的一行代码在此处:<br><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = <span class="hljs-keyword">new</span> ReactCompositeComponentWrapper(element);</span><br></pre></td></tr></table></figure></p><p>关键角色<code>ReactCompositeComponentWrapper</code>是干什么的呢? 又和我们提到的<code>ReactCompositeComponent</code>有什么纠缠不清的关系呢? 下面几行代码就可以告诉你事情的真相:<br><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> ReactCompositeComponentWrapper = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.construct(element);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-built_in">Object</span>.assign(</span><br><span class="line">  ReactCompositeComponentWrapper.prototype,</span><br><span class="line">  ReactCompositeComponent,</span><br><span class="line">  &#123;</span><br><span class="line">    _instantiateReactComponent: instantiateReactComponent,</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><code>ReactCompositeComponentWrapper</code>就跟他的名字一样, 是对<code>ReactCompositeComponent</code>这个类的一个包装类, 所有的类方法都来自于我们今天要说到的主角<code>ReactCompositeComponent</code>.</p><hr><h3 id="ReactCompositeComponent"><a href="#ReactCompositeComponent" class="headerlink" title="ReactCompositeComponent"></a><code>ReactCompositeComponent</code></h3><p>源码地址: <a href="https://github.com/facebook/react/blob/v15.6.2/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js" target="_blank" rel="noopener">ReactCompositeComponent.js</a></p><p>下面接着对<code>ReactCompositeComponent</code>做一下分析, 某些方法的具体内容会省略掉, 如果有需要可以自行查阅源码当中的具体代码, 方便节省篇幅以及更易于阅读.<br><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> ReactCompositeComponent = &#123;</span><br><span class="line">  construct: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;, <span class="hljs-comment">// 用于初始化组件的元信息(Metadata)</span></span><br><span class="line">  mountComponent: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> inst = <span class="hljs-keyword">this</span>._constructComponent(...); <span class="hljs-comment">// 生命周期函数的启动入口,</span></span><br><span class="line">    <span class="hljs-keyword">var</span> markup; <span class="hljs-comment">// render方法返回的ReactElement就是这个markup</span></span><br><span class="line">    markup = performInitialMount(...);</span><br><span class="line">    <span class="hljs-keyword">if</span> (inst.componentDidMount) inst.componentDidMount(); <span class="hljs-comment">// 第三个钩子函数调用</span></span><br><span class="line">    <span class="hljs-keyword">return</span> markup;</span><br><span class="line">  &#125;,</span><br><span class="line">  _constructComponent: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;, <span class="hljs-comment">// 这个方法会调用下面这个方法</span></span><br><span class="line">  _constructComponentWithoutOwner: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Component(publicProps, publicContext, updateQueue); <span class="hljs-comment">// 被包起来的Component被实例化</span></span><br><span class="line">  &#125;,</span><br><span class="line">  performInitialMount: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> ins = <span class="hljs-keyword">this</span>._instance;</span><br><span class="line">    <span class="hljs-keyword">if</span> (ins.componentWillMount) ins.componentWillMount(); <span class="hljs-comment">// 第一个钩子函数的调用</span></span><br><span class="line">    <span class="hljs-comment">// 比较重要的地方: 当在初始挂载的阶段如果有发现`setState`方法被调用, 便会通过同步的方式来处理, 很好的避免了setState导致的重新渲染, 来提高整体的性能.</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._pendingStateQueue) &#123;</span><br><span class="line">      inst.state = <span class="hljs-keyword">this</span>._processPendingState(inst.props, inst.context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (renderedElement === <span class="hljs-literal">undefined</span>) &#123;</span><br><span class="line">      <span class="hljs-comment">// 近似等于: renderedElement = this._instance.render();</span></span><br><span class="line">      renderedElement = <span class="hljs-keyword">this</span>._renderValidatedComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">var</span> child = <span class="hljs-keyword">this</span>._instantiateReactComponent(...) <span class="hljs-comment">// 递归实例化子组件</span></span><br><span class="line">    <span class="hljs-keyword">var</span> markup = ReactReconciler.mountComponent(child, ...); <span class="hljs-comment">// 递归得到完整的树.</span></span><br><span class="line">    <span class="hljs-keyword">return</span> markup;</span><br><span class="line">  &#125;,</span><br><span class="line">  _renderValidatedComponent: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._renderValidatedComponentWithoutOwnerOrContext();</span><br><span class="line">  &#125;,</span><br><span class="line">  _renderValidatedComponentWithoutOwnerOrContext: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._instance.render(); <span class="hljs-comment">// 第二个钩子的调用</span></span><br><span class="line">  &#125;,</span><br><span class="line">  receiveComponent: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...</span>) </span>&#123; <span class="hljs-comment">// 调用该方法来更新Component</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.updateComponent(...); </span><br><span class="line">  &#125;,</span><br><span class="line">  updateComponent: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...</span>) </span>&#123; <span class="hljs-comment">// 后面会讲到这些更新条件如何被满足</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123;</span><br><span class="line">      inst.componentWillReceiveProps(); <span class="hljs-comment">// 第四个钩子函数的调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">var</span> shouldUpdate = inst.shouldComponentUpdate(); <span class="hljs-comment">// 第五个钩子函数调用</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (shouldUpdate) <span class="hljs-keyword">this</span>._performComponentUpdate();</span><br><span class="line">  &#125;,</span><br><span class="line">  _performComponentUpdate: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    inst.componentWillUpdate(...); <span class="hljs-comment">// 第六个钩子函数的调用.</span></span><br><span class="line">    <span class="hljs-keyword">this</span>._updateRenderedComponent(...); <span class="hljs-comment">// 更新; 内部调用第七个钩子函数 Component.render();</span></span><br><span class="line">    inst.componentDidUpdate &amp;&amp; inst.componentDidUpdate(); <span class="hljs-comment">// 第八个个钩子函数调用</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="hljs-comment">// 里面是Component更新的操作 简单来说就是销毁掉原有的节点, 然后重新实例化新的节点挂载.</span></span><br><span class="line">  _updateRenderedComponent: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; &#125;,</span><br><span class="line">  unmountComponent: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; &#125; <span class="hljs-comment">// 递归卸载节点, 调用子节点的 componentWillUnmount方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结:"></a>本章小结:</h4><p><code>ReactCompositeComponent</code> 的内容基本就是挂载/更新/卸载等操作. 除了<code>CompositeComponent</code>, 在<code>instantiateReactComponent</code>方法中, 能够看到React中一共有4种Component类型.</p><ol><li>ReactCompositeComponent<ul><li>InternalComponent. <code>// 可以理解为React的官方标准组件库</code></li><li>UserDefinedComponent <code>// 用户自定义</code></li></ul></li><li>ReactDOMComponent <code>// DOM节点相关的Component, 自定义的Component最后都会被处理成该类型的</code></li><li>ReactTextComponent <code>// 字面量节点, 如 &quot;Some string&quot; &quot;12312&quot;</code></li><li>ReactEmptyComponent <code>// 空节点</code></li></ol><hr><h4 id="下期预告-从React-render-的调用开始-到底发生了什么"><a href="#下期预告-从React-render-的调用开始-到底发生了什么" class="headerlink" title="下期预告: 从React.render()的调用开始, 到底发生了什么?"></a>下期预告: 从<code>React.render()</code>的调用开始, 到底发生了什么?</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;/strong&gt; &lt;code&gt;ReactCompositeComponent&lt;/code&gt; &lt;code&gt;instantiate&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;让我们先实例化一个组件&quot;&gt;&lt;a href=&quot;#让我们先实例化一个组件&quot; class=&quot;headerlink&quot; title=&quot;让我们先实例化一个组件&quot;&gt;&lt;/a&gt;让我们先实例化一个组件&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;/2018/07/20/React源码阅读系列-§1.3先给我整一个Component/&quot;&gt;上一章&lt;/a&gt;讲到了, React的&lt;code&gt;Component&lt;/code&gt;种类, 但没讲到用户自己写的&lt;code&gt;CustomComponent&lt;/code&gt;是怎么被实例化的. 在后面的章节会介绍到关于应用启动的过程到底发生了哪些事情, 在这边就先简单的做一个铺垫. 主要关注在&lt;code&gt;CustomComponent&lt;/code&gt;的实例化过程.&lt;/p&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>React源码阅读系列 - §1.3 先给我整一个 Component</title>
    <link href="https://jeremywu.info/2018/07/20/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A71.3%E5%85%88%E7%BB%99%E6%88%91%E6%95%B4%E4%B8%80%E4%B8%AAComponent/"/>
    <id>https://jeremywu.info/2018/07/20/React源码阅读系列-§1.3先给我整一个Component/</id>
    <published>2018-07-20T13:43:41.000Z</published>
    <updated>2019-03-31T06:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字: </strong> <code>BaseComponent</code> <code>CustomComponent</code> <code>PureComponent</code> <code>Statelesscomponent</code></p><p>上回书说道, 所有人写的JSX(TSX)代码, 都会被对应的编译器给翻译成<code>React.createElement</code>形式的代码.<br>那么, 一个<code>CustomdComponent</code>是怎么样被React渲染的呢?</p><h4 id="来整懂嘛是一个ReactComponent"><a href="#来整懂嘛是一个ReactComponent" class="headerlink" title="来整懂嘛是一个ReactComponent"></a>来整懂嘛是一个ReactComponent</h4><a id="more"></a><hr><p>在开始之前, 先要公布一下<a href="/2018/07/18/React源码阅读系列-§1.2先有节点后有天%20ReactCreateElement/">上一篇</a>文章的练习题答案.</p><p>编译后代码如下:<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> React.createElement(</span><br><span class="line">                      <span class="hljs-string">'div'</span>, <span class="hljs-comment">// type</span></span><br><span class="line">                      &#123;<span class="hljs-attr">className</span>: <span class="hljs-string">'container'</span>&#125;, <span class="hljs-comment">// props</span></span><br><span class="line">                      React.createElement(            <span class="hljs-comment">//  - |</span></span><br><span class="line">                        <span class="hljs-string">'span'</span>,   <span class="hljs-comment">//type              //    |--&gt; children</span></span><br><span class="line">                        &#123;<span class="hljs-attr">className</span>: <span class="hljs-string">'sub'</span>&#125;, <span class="hljs-comment">// props  //  - |</span></span><br><span class="line">                        <span class="hljs-literal">null</span>) <span class="hljs-comment">// children</span></span><br><span class="line">                      );</span><br></pre></td></tr></table></figure></p><p>上面的方法运行出来的结果为: </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $$<span class="hljs-keyword">typeof</span>: <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.element'</span>)</span><br><span class="line">  type: <span class="hljs-string">'div'</span>,</span><br><span class="line">  key: <span class="hljs-literal">null</span>,</span><br><span class="line">  ref: <span class="hljs-literal">null</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="hljs-string">'container'</span>,</span><br><span class="line">    children: &#123;</span><br><span class="line">      $$<span class="hljs-keyword">typeof</span>: <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.element'</span>)</span><br><span class="line">      type: <span class="hljs-string">'span'</span>,</span><br><span class="line">      key: <span class="hljs-literal">null</span>,</span><br><span class="line">      ref: <span class="hljs-literal">null</span>,</span><br><span class="line">      props: &#123;</span><br><span class="line">        className: <span class="hljs-string">'sub'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      _owner: <span class="hljs-literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  _owner: <span class="hljs-literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>&emsp;&emsp;&nbsp;在<strong>ES6</strong> A.K.A. <a href="https://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">ECMAScript2015®</a>以及更高版本的<a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm" target="_blank" rel="noopener">ECMAScript®</a>越来越普及的今天, 并且各种超集(Superset)/下一代编译器(Next Gen Compiler)如: <a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">Typescript®</a>, <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel®</a>的普及, 我们更多的是利用<code>class</code>语法来定义我们的<code>ReactComponent</code>, 而非早期版本的<code>React.createClass</code>, 且<code>React.createClass</code>在16.0+版本就已经被宣布废弃, 所以在这边就只对官方提供的三种Component:<br>&emsp;&emsp;&nbsp;&nbsp;i. <code>Component</code> 也叫 <code>BaseComponent</code><br>&emsp;&emsp;&nbsp;ii. <code>PureComponent</code><br>&emsp;&emsp;iii. <code>StatelessComponent</code> 也叫 <code>FunctionalComponent</code><br>做一个简单的分析.</p><h4 id="i-BaseComponent"><a href="#i-BaseComponent" class="headerlink" title="i. BaseComponent"></a>i. BaseComponent</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReactComponent</span>(<span class="hljs-params">props, context, updater</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.props = props;</span><br><span class="line">  <span class="hljs-keyword">this</span>.context = context;</span><br><span class="line">  <span class="hljs-keyword">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="hljs-keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line">ReactComponent.prototype.isReactComponent = &#123;&#125;;</span><br><span class="line">ReactComponent.prototype.setState = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;; <span class="hljs-comment">// ...省略实现, 后面会专门讲这个方法</span></span><br><span class="line">ReactComponent.prototype.forceUpdate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;; <span class="hljs-comment">//.. 同上</span></span><br></pre></td></tr></table></figure><h4 id="ii-PureComponent"><a href="#ii-PureComponent" class="headerlink" title="ii. PureComponent"></a>ii. PureComponent</h4><p><code>PureComponent</code>其实基本上跟<code>ReactComponent</code>等价, 唯一不同的地方在这段代码, 而不同点将会在后面的文章当中对其进行介绍.<br><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactPureComponent.prototype.isPureReactComponent = <span class="hljs-literal">true</span>;</span><br></pre></td></tr></table></figure></p><h4 id="iii-StatelessComponent"><a href="#iii-StatelessComponent" class="headerlink" title="iii. StatelessComponent"></a>iii. StatelessComponent</h4><p><code>StatelessComponent</code>较前两者而言由于不提供任何的生命周期函数, 在特定情况下的性能也许会比前两者稍微好一点. 其更大的优势是在于, 简化了<code>Component</code>本身的一个抽象过程, 可以减少非常多的代码量.</p><p>以上是React系统中用户可自定义的三种<code>Component</code>. 这三者其实并没有实际定义所谓的生命周期等函数. 详情请见下回分解.</p><hr><h4 id="下期预告-ReactCompositeComponent"><a href="#下期预告-ReactCompositeComponent" class="headerlink" title="下期预告: ReactCompositeComponent"></a>下期预告: <code>ReactCompositeComponent</code></h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键字: &lt;/strong&gt; &lt;code&gt;BaseComponent&lt;/code&gt; &lt;code&gt;CustomComponent&lt;/code&gt; &lt;code&gt;PureComponent&lt;/code&gt; &lt;code&gt;Statelesscomponent&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上回书说道, 所有人写的JSX(TSX)代码, 都会被对应的编译器给翻译成&lt;code&gt;React.createElement&lt;/code&gt;形式的代码.&lt;br&gt;那么, 一个&lt;code&gt;CustomdComponent&lt;/code&gt;是怎么样被React渲染的呢?&lt;/p&gt;
&lt;h4 id=&quot;来整懂嘛是一个ReactComponent&quot;&gt;&lt;a href=&quot;#来整懂嘛是一个ReactComponent&quot; class=&quot;headerlink&quot; title=&quot;来整懂嘛是一个ReactComponent&quot;&gt;&lt;/a&gt;来整懂嘛是一个ReactComponent&lt;/h4&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>React源码阅读系列 - §1.2先有节点后有天 ReactCreateElement</title>
    <link href="https://jeremywu.info/2018/07/18/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A71.2%E5%85%88%E6%9C%89%E8%8A%82%E7%82%B9%E5%90%8E%E6%9C%89%E5%A4%A9%20ReactCreateElement/"/>
    <id>https://jeremywu.info/2018/07/18/React源码阅读系列-§1.2先有节点后有天 ReactCreateElement/</id>
    <published>2018-07-18T14:18:17.000Z</published>
    <updated>2019-03-31T06:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键词:</strong> <code>ReactElement</code> <code>JSX</code></p><h3 id="一切都要从ReactDOM-render讲起"><a href="#一切都要从ReactDOM-render讲起" class="headerlink" title="一切都要从ReactDOM.render讲起"></a>一切都要从ReactDOM.render讲起</h3><figure class="highlight jsx hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ReactDom <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> Example <span class="hljs-keyword">from</span> <span class="hljs-string">'example'</span>;</span><br><span class="line">ReactDOM.render(&lt;Example/&gt;, <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#root'</span>));</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h4 id="从一个错误说起"><a href="#从一个错误说起" class="headerlink" title="从一个错误说起"></a>从一个错误说起</h4><p>相信不少的人都犯过这样一个错误:<br><figure class="highlight jsx hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123; </span><br><span class="line">  </span><br><span class="line">  render() &#123;  </span><br><span class="line">    <span class="hljs-keyword">return</span> &lt;div&gt;Example&lt;/div&gt;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">Error</span>: React is not defined.</span><br></pre></td></tr></table></figure></p><p>明明我这里并没有用到<code>React</code>这个关键字为什么会告诉我说<code>React is not defined</code>呢?</p><p>&emsp;&emsp;&nbsp;答案就是当你写JSX的代码时, 都是需要通过我们的一些编译工具把JSX代码编译成JavaScript代码, 这样浏览器才能够运行. 而这里的编译过程正好是用到了<code>React</code>这个库上所提供的<code>createElement</code>方法, 所以才会有上面这一行错误.</p><p>上面的代码等同于:</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// ...省略</span></span><br><span class="line"><span class="hljs-keyword">class</span> SomeComponent <span class="hljs-keyword">extends</span> React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> React.createElement(<span class="hljs-string">'div'</span>, <span class="hljs-literal">null</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// ...省略</span></span><br></pre></td></tr></table></figure><hr><h4 id="具体分析createElement方法到底是干了什么"><a href="#具体分析createElement方法到底是干了什么" class="headerlink" title="具体分析createElement方法到底是干了什么"></a>具体分析<code>createElement</code>方法到底是干了什么</h4><p><code>createElement</code>方法的方法签名:</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, config, children</span>)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>类型</th></tr></thead><tbody><tr><td>type</td><td><code>string</code> or <code>ReactCompositeComponent</code></td></tr><tr><td>config</td><td><code>any</code></td></tr><tr><td>children</td><td><code>any</code></td></tr><tr><td>返回值</td><td><code>ReactElement</code></td></tr></tbody></table><p>从函数签名上可以不难看出, 在构造节点时, <code>React</code> 是需要知道要构造的节点的<strong>类型</strong>, 节点需要用到的一些<strong>属性值</strong>, 以及节点的<strong>子节点</strong>, 然后返回了一个<code>ReactElement</code>实体.</p><div class="tip"><br>  注:&emsp;<strong>一个元素节点上的子节点可以看做该节点的属性值(Property).</strong><br></div><p>接下来进入方法内部, 看这个方法到底做了一些什么事情, 该方法最后返回的结果又是什么, 省略掉一部分无关紧要的代码, 某些代码格式为了篇幅稍有整改但不影响正确性.<br><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">React.createElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, config, children</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> propName;</span><br><span class="line">  <span class="hljs-keyword">var</span> props = &#123;&#125;, key = ref = self = source = <span class="hljs-literal">null</span>;</span><br><span class="line">  <span class="hljs-comment">// 传递属性</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (config != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">    <span class="hljs-comment">// 关键属性, 后面会分析到.</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (hasValidRef(config)) &#123;</span><br><span class="line">      ref = config.ref;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 判断当前节点是否具有有效的特殊key, key属性也是节点的保留属性, 为React的diff做了非常大的贡献</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (hasValidKey(config)) &#123;</span><br><span class="line">      key = <span class="hljs-string">''</span> + config.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self = config.__self === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : config.__self;</span><br><span class="line">    source = config.__source === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : config.__source;</span><br><span class="line">    <span class="hljs-keyword">for</span> (propName <span class="hljs-keyword">in</span> config) &#123;</span><br><span class="line">      <span class="hljs-comment">// ... 省略属性的复制</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// 把子节点作为当前根节点上的属性</span></span><br><span class="line">  <span class="hljs-keyword">var</span> childrenLength = <span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">2</span>;</span><br><span class="line">  <span class="hljs-keyword">if</span> (childrenLength === <span class="hljs-number">1</span>) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childrenLength &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">    <span class="hljs-comment">// 此处代码为本文作者调整 原始代码可参见文末给出地址</span></span><br><span class="line">    props.children = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 处理根节点上的默认的属性</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> &amp;&amp; <span class="hljs-keyword">type</span>.defaultProps) &#123;</span><br><span class="line">    <span class="hljs-comment">// ... 省略默认属性的复制</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// 返回一个ReactElement节点</span></span><br><span class="line">  <span class="hljs-keyword">return</span> ReactElement(<span class="hljs-keyword">type</span>, key, ref, self, source, ReactCurrentOwner.current, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;&nbsp;透过这个方法其实不难看出, <code>React.createElement</code>整个方法内部, 都是在做一系列的数据处理, 然后把处理好的数据输入给<code>ReactElement</code>这个方法, 通过该方法来构造出一个真正的<code>ReactElement</code>节点.</p><hr><h5 id="ReactElement到底是个什么东西"><a href="#ReactElement到底是个什么东西" class="headerlink" title="ReactElement到底是个什么东西?"></a><code>ReactElement</code>到底是个什么东西?</h5><p>&emsp;&emsp;&nbsp;从上面最后一行可以看出来, 最后通过构造方法调用, 返回了一个真实的<code>ReactElement</code>, 这里其实可以看做一个类实例构造类似 省略掉<code>new</code>操作符的类构造器调用.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// ... 这个markdown的支持可真烂</span></span><br><span class="line"><span class="hljs-keyword">var</span> ReactElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">    $$<span class="hljs-keyword">typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    props,</span><br><span class="line">    _owner: owner</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>$$typeof</td><td><code>Symbol</code></td><td>标识该对象是一个ReactElement</td></tr><tr><td>type</td><td><code>any</code></td><td>该Element的类型</td></tr><tr><td>key</td><td><code>string</code></td><td>标识该节点的独有key</td></tr><tr><td>ref</td><td><code>object</code> or <code>function</code></td><td>该节点对象的引用</td></tr><tr><td>props</td><td><code>object</code></td><td>该节点的所有属性</td></tr><tr><td>_owner</td><td><code>any</code></td><td>标识该节点的所有者</td></tr></tbody></table><hr><h4 id="最后的小测试"><a href="#最后的小测试" class="headerlink" title="最后的小测试:"></a>最后的小测试:</h4><p>尝试人为调用上述的<code>React.createElement</code>方法来得到一个<code>ReactElement</code>然后用树形结构表示出来, 答案在下一章开头.<br><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sub"</span>&gt;</span>Text Node<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="下期预告-ReactComponent"><a href="#下期预告-ReactComponent" class="headerlink" title="下期预告: ReactComponent"></a>下期预告: ReactComponent</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键词:&lt;/strong&gt; &lt;code&gt;ReactElement&lt;/code&gt; &lt;code&gt;JSX&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;一切都要从ReactDOM-render讲起&quot;&gt;&lt;a href=&quot;#一切都要从ReactDOM-render讲起&quot; class=&quot;headerlink&quot; title=&quot;一切都要从ReactDOM.render讲起&quot;&gt;&lt;/a&gt;一切都要从ReactDOM.render讲起&lt;/h3&gt;&lt;figure class=&quot;highlight jsx hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; React &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;react&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; ReactDom &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;react-dom&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Example &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;example&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ReactDOM.render(&amp;lt;Example/&amp;gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;document&lt;/span&gt;.querySelector(&lt;span class=&quot;hljs-string&quot;&gt;&#39;#root&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>React源码阅读系列 - §1.1 生命周期 Life cycle</title>
    <link href="https://jeremywu.info/2018/07/17/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A71.1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-Lifecycle/"/>
    <id>https://jeremywu.info/2018/07/17/React源码阅读系列-§1.1-生命周期-Lifecycle/</id>
    <published>2018-07-17T13:25:22.000Z</published>
    <updated>2019-03-31T06:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键词:</strong> <code>Lifecycle</code> <code>生命周期</code></p><h1 id="React的生命周期"><a href="#React的生命周期" class="headerlink" title="React的生命周期"></a>React的生命周期</h1><p>&emsp;&emsp;&nbsp;每一个软件都有他的生命周期, React也不例外, 从React的Tutorial就开始向每一个用户介绍React的生命周期, React的各种内嵌钩子函数的使用. 下面来详细介绍一下React的生命周期到底有哪几个过程.</p><a id="more"></a><h3 id="通过一张图来理解"><a href="#通过一张图来理解" class="headerlink" title="通过一张图来理解:"></a>通过一张图来理解:</h3><img src="/2018/07/17/React源码阅读系列-§1.1-生命周期-Lifecycle/lifecycle.png" title="lifecycle"><h3 id="通过一段注释来理解"><a href="#通过一段注释来理解" class="headerlink" title="通过一段注释来理解:"></a>通过一段注释来理解:</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * ------------------ The Life-Cycle of a Composite Component ------------------</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * - constructor: Initialization of state. The instance is now retained.</span></span><br><span class="line"><span class="hljs-comment"> *   - componentWillMount</span></span><br><span class="line"><span class="hljs-comment"> *   - render</span></span><br><span class="line"><span class="hljs-comment"> *   - [children's constructors]</span></span><br><span class="line"><span class="hljs-comment"> *     - [children's componentWillMount and render]</span></span><br><span class="line"><span class="hljs-comment"> *     - [children's componentDidMount]</span></span><br><span class="line"><span class="hljs-comment"> *     - componentDidMount</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> *       Update Phases:</span></span><br><span class="line"><span class="hljs-comment"> *       - componentWillReceiveProps (only called if parent updated)</span></span><br><span class="line"><span class="hljs-comment"> *       - shouldComponentUpdate</span></span><br><span class="line"><span class="hljs-comment"> *         - componentWillUpdate</span></span><br><span class="line"><span class="hljs-comment"> *           - render</span></span><br><span class="line"><span class="hljs-comment"> *           - [children's constructors or receive props phases]</span></span><br><span class="line"><span class="hljs-comment"> *         - componentDidUpdate</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> *     - componentWillUnmount</span></span><br><span class="line"><span class="hljs-comment"> *     - [children's componentWillUnmount]</span></span><br><span class="line"><span class="hljs-comment"> *   - [children destroyed]</span></span><br><span class="line"><span class="hljs-comment"> * - (destroyed): The instance is now blank, released by React and ready for GC.</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br></pre></td></tr></table></figure><div class="tip"><br><p>注:</p><br><br><p>i. 该注释出处为React 源码仓库中的<a href="https://github.com/facebook/react/blob/v15.6.2/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js#L88" target="_blank" rel="noopener">ReactCompositeComponent.js</a></p><br><p>ii. 通过用户编写的<strong>Component</strong>都是一个<strong>Composite Component</strong></p><br></div><h3 id="ReactComponent生命周期以及所对应的钩子函数-Hook"><a href="#ReactComponent生命周期以及所对应的钩子函数-Hook" class="headerlink" title="ReactComponent生命周期以及所对应的钩子函数(Hook)"></a>ReactComponent生命周期以及所对应的钩子函数(Hook)</h3><ol><li><p>Component 创建:<br>i. Component Constructor - 初始化State Props<br>ii. ComponentWillMount - Hook API<br>iii. render - 创建节点<br>iv. ComponentDidMount - Hook API</p></li><li><p>Component 更新<br>i. ShouldComponentUpdate - Hook API<br>ii. ComponentWillUpdate - Hook API<br>iii. render - 更新节点<br>iv. ComponentDidUpdate - Hook API</p></li><li><p>Component 销毁<br>i. ComponentWillUnmount - Hook API<br>ii. 类似 <code>someComponent = null;</code> - 等待GC</p></li></ol><h3 id="下期预告-React-createElement"><a href="#下期预告-React-createElement" class="headerlink" title="下期预告: React.createElement"></a>下期预告: <code>React.createElement</code></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键词:&lt;/strong&gt; &lt;code&gt;Lifecycle&lt;/code&gt; &lt;code&gt;生命周期&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;React的生命周期&quot;&gt;&lt;a href=&quot;#React的生命周期&quot; class=&quot;headerlink&quot; title=&quot;React的生命周期&quot;&gt;&lt;/a&gt;React的生命周期&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;nbsp;每一个软件都有他的生命周期, React也不例外, 从React的Tutorial就开始向每一个用户介绍React的生命周期, React的各种内嵌钩子函数的使用. 下面来详细介绍一下React的生命周期到底有哪几个过程.&lt;/p&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>React源码阅读系列 - §0 简介 Intro</title>
    <link href="https://jeremywu.info/2018/07/16/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97-%C2%A70%20%E7%AE%80%E4%BB%8B%20Intro/"/>
    <id>https://jeremywu.info/2018/07/16/React源码阅读系列-§0 简介 Intro/</id>
    <published>2018-07-16T13:43:51.000Z</published>
    <updated>2019-03-31T06:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键词:</strong> <code>React</code> <code>源码分析</code></p><h1 id="React-源码阅读"><a href="#React-源码阅读" class="headerlink" title="React 源码阅读"></a>React 源码阅读</h1><p><strong>&emsp;&emsp;&nbsp;最近由于工作变动, 被调到了新的部门, 新的部门里的很多代码并不熟悉, 便只能硬着头皮看下去, 随即发现了一个问题, 跳出舒适圈的我, 在看代码的过程中, 学到了非常多的东西, 想要想办法证明自己, 于是便想开这么一篇React的源码阅读的坑, 准备花一段时间来阅读以及记录自己对源码阅读后的理解和感悟.</strong></p><h3 id="React版本"><a href="#React版本" class="headerlink" title="React版本"></a>React版本</h3><div class="tip"><br><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"Name"</span>: <span class="hljs-string">"React"</span>,</span><br><span class="line">  <span class="hljs-attr">"Version"</span>: <span class="hljs-string">"15.6.2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></div><a id="more"></a><h3 id="核心概念-Core-Concepts"><a href="#核心概念-Core-Concepts" class="headerlink" title="核心概念 (Core Concepts):"></a>核心概念 (Core Concepts):</h3><p><strong>0. 基础部分 (Pre-requirement)</strong></p><ul><li>生命周期</li><li>从 JSX (TSX) 到 JS</li></ul><p><strong>1. 启动部分 (在应用启动时的代码分析)</strong></p><ul><li>从组件 (<strong>Component</strong>) 到 虚拟节点 (<strong>Virtual Node</strong>)</li><li>从虚拟节点 (<strong>Virtual Node</strong>) 到 真实DOM节点 (<strong>Actual Node</strong>)</li></ul><p><strong>2. 存在周期 (在存在周期时的代码分析)</strong></p><ul><li>事件机制 (Event Handling)</li><li>事务处理 (Transaction Operation)</li><li>更新操作 (Updating Action)<br>i. 数据更新 (Data Updating)<br>ii. 视图更新 (Layout Updating)</li><li>组件间的通信 (Component Communication)</li><li>Diff的算法分析 (Diff Algorithm)</li></ul><p><strong>3. 总结</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键词:&lt;/strong&gt; &lt;code&gt;React&lt;/code&gt; &lt;code&gt;源码分析&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;React-源码阅读&quot;&gt;&lt;a href=&quot;#React-源码阅读&quot; class=&quot;headerlink&quot; title=&quot;React 源码阅读&quot;&gt;&lt;/a&gt;React 源码阅读&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&amp;emsp;&amp;emsp;&amp;nbsp;最近由于工作变动, 被调到了新的部门, 新的部门里的很多代码并不熟悉, 便只能硬着头皮看下去, 随即发现了一个问题, 跳出舒适圈的我, 在看代码的过程中, 学到了非常多的东西, 想要想办法证明自己, 于是便想开这么一篇React的源码阅读的坑, 准备花一段时间来阅读以及记录自己对源码阅读后的理解和感悟.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;React版本&quot;&gt;&lt;a href=&quot;#React版本&quot; class=&quot;headerlink&quot; title=&quot;React版本&quot;&gt;&lt;/a&gt;React版本&lt;/h3&gt;&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;&lt;figure class=&quot;highlight json hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;Name&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;React&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;Version&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;15.6.2&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="React源码阅读系列" scheme="https://jeremywu.info/categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="React源码阅读" scheme="https://jeremywu.info/tags/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
