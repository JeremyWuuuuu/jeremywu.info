<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> React源码阅读系列-§2.3-事务机制 · Jeremy's Note</title><meta name="description" content="React生命周期函数详解"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://jeremywu.info/atom.xml" title="Jeremy's Note"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/JeremyWuuuuu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">React源码阅读系列-§2.3-事务机制</h1><div class="post-info">2018年8月6日</div><div class="post-content"><p><strong>关键字: </strong> <code>transaction</code> <code>batch operation</code></p>
<h3 id="事务-Transaction-的原理"><a href="#事务-Transaction-的原理" class="headerlink" title="事务(Transaction)的原理"></a>事务(Transaction)的原理</h3><p>在前面有几节中反复提到了React的事务机制(Transaction), 今天就准备来讲一讲这个事务机制到底是怎么个一回事.<br>用一句简单一点的话来形容这个东西就是: 在调用某一个具体的方法之前与之后, 先调用一系列的处理函数, 类似于<code>npm install</code>对应的<code>npm preinstall</code>和<code>npm postinstall</code>, 分别执行于<code>npm install</code>这个脚本的开始之前与完成之后.</p>
<a id="more"></a>
<h4 id="用一幅图来说明"><a href="#用一幅图来说明" class="headerlink" title="用一幅图来说明:"></a>用一幅图来说明:</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *                       wrappers (injected at creation time)</span></span><br><span class="line"><span class="comment"> *                                      +        +</span></span><br><span class="line"><span class="comment"> *                                      |        |</span></span><br><span class="line"><span class="comment"> *                    +-----------------|--------|--------------+</span></span><br><span class="line"><span class="comment"> *                    |                 v        |              |</span></span><br><span class="line"><span class="comment"> *                    |      +---------------+   |              |</span></span><br><span class="line"><span class="comment"> *                    |   +--|    wrapper1   |---|----+         |</span></span><br><span class="line"><span class="comment"> *                    |   |  +---------------+   v    |         |</span></span><br><span class="line"><span class="comment"> *                    |   |          +-------------+  |         |</span></span><br><span class="line"><span class="comment"> *                    |   |     +----|   wrapper2  |--------+   |</span></span><br><span class="line"><span class="comment"> *                    |   |     |    +-------------+  |     |   |</span></span><br><span class="line"><span class="comment"> *                    |   |     |                     |     |   |</span></span><br><span class="line"><span class="comment"> *                    |   v     v                     v     v   | wrapper</span></span><br><span class="line"><span class="comment"> *                    | +---+ +---+   +---------+   +---+ +---+ | invariants</span></span><br><span class="line"><span class="comment"> * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained</span></span><br><span class="line"><span class="comment"> * +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt;</span></span><br><span class="line"><span class="comment"> *                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="comment"> *                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="comment"> *                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="comment"> *                    | +---+ +---+   +---------+   +---+ +---+ |</span></span><br><span class="line"><span class="comment"> *                    |  initialize                    close    |</span></span><br><span class="line"><span class="comment"> *                    +-----------------------------------------+</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><div class="tip"><br>该图版权属于React开发团队所有.</div></p>
<p><div><br>在某些框架的源码中其实也依稀可见这种处理的思想, 类似但不仅限于对<code>Array</code>的Native方法的劫持调用, 如<a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a>早期版本当中对<code>Array</code>的处理用来添加函数处理.</div></p>
<h4 id="事务类的接口定义"><a href="#事务类的接口定义" class="headerlink" title="事务类的接口定义:"></a>事务类的接口定义:</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TransactionImpl = &#123;</span><br><span class="line">  reinireinitializeTransaction: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>; <span class="comment">// 重置wrapper</span></span><br><span class="line">  _isIntransaction: <span class="built_in">boolean</span>; <span class="comment">// transaction调度时标识符</span></span><br><span class="line">  getTransactionWrappers: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Array</span>&lt;TransactionWrapper&gt;; <span class="comment">// 拿到所有wrapper</span></span><br><span class="line">  isInTransaction: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">boolean</span>; <span class="comment">// 得到_isIntransaction属性</span></span><br><span class="line">  perform: &lt;A, B, C, D, E, F, G, T: <span class="function">(<span class="params">a: A, b: B, c: C, d: D, e: E, f: F</span>) =&gt;</span> G&gt;</span><br><span class="line">    (method: T, scope: <span class="built_in">any</span>, a: A, b: B, c: C, d: D, e: E, f: F) =&gt; G; <span class="comment">// 事务调度 </span></span><br><span class="line">    <span class="comment">// 在perform方法中先后调用 this.initializeAll(index) 和 this.closeAll(index)</span></span><br><span class="line">  initializeAll: <span class="function">(<span class="params">startIndex: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>; <span class="comment">// 执行所有wrapper中的initialize方法</span></span><br><span class="line">  closeAll: <span class="function">(<span class="params">startIndex: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>; <span class="comment">// 执行所有wrapper中的close方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在React整个系统中一共实现了3种事务操作类(服务端渲染和ReactNative不算).</p>
<ol>
<li>ReactUpdatesFlushTransaction</li>
<li>ReactBatchingStrategyTransaction</li>
<li>ReactReconcileTransaction</li>
</ol>
<p>每一种事务类都负责处理对应的操作(下面会说到).</p>
<p><code>ReactUpdates.batchedUpdates()</code>方法被用来启动整个更新的操作, 然后把这个操作的分配工作交给<code>ReactBatchingUpdateStrategyTransaction</code></p>
<h4 id="ReactBatchingUpdateStrategyTransaction的Wrapper实现以及功能"><a href="#ReactBatchingUpdateStrategyTransaction的Wrapper实现以及功能" class="headerlink" title="ReactBatchingUpdateStrategyTransaction的Wrapper实现以及功能:"></a>ReactBatchingUpdateStrategyTransaction的Wrapper实现以及功能:</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TransactionImpl <span class="keyword">from</span> <span class="string">'Transaction'</span>;</span><br><span class="line"><span class="comment">// 定义Wrapper1号</span></span><br><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction, <span class="comment">// 空方法</span></span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 标志位置回false</span></span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义Wrapper2号</span></span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction, <span class="comment">// 空方法</span></span><br><span class="line">  <span class="comment">// 更新DOM</span></span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS: <span class="built_in">Array</span>&lt;TransactionWrapper&gt; = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当在调用这个transaction.perform方法的时候实际上是这样的:</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *            +----------------------+    +---------------------+        +----------+</span></span><br><span class="line"><span class="comment"> * perform -&gt; |FLUSH_BATCHED_UPDATES.| -&gt; |REST_BATCHED_UPDATES.| -----&gt; |  method  |</span></span><br><span class="line"><span class="comment"> *            |      initialize      |    |      initialize     |        |          |</span></span><br><span class="line"><span class="comment"> *            +----------------------+    +---------------------+        +----------+</span></span><br><span class="line"><span class="comment"> *                                                                            |</span></span><br><span class="line"><span class="comment"> *            +----------------------+    +----------------------+            |</span></span><br><span class="line"><span class="comment"> *            |REST_BATCHED_UPDATES. |    |FLUSH_BATCHED_UPDATES.|            |</span></span><br><span class="line"><span class="comment"> *            |        close         |    |        close         | &lt;----------+</span></span><br><span class="line"><span class="comment"> *            +----------------------+    +----------------------+</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><code>ReactUpdates.flushBatchedUpdates</code>调用<code>ReactUpdatesFlushTransaction.perform(runBatchedUpdates)方法</code>👇.</p>
<h4 id="ReactUpdatesFlushTransaction的实现以及功能"><a href="#ReactUpdatesFlushTransaction的实现以及功能" class="headerlink" title="ReactUpdatesFlushTransaction的实现以及功能"></a>ReactUpdatesFlushTransaction的实现以及功能</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrapper1号定义</span></span><br><span class="line"><span class="keyword">var</span> NESTED_UPDATES = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dirtyComponentsLength = dirtyComponents.length;</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dirtyComponentsLength !== dirtyComponents.length) &#123;</span><br><span class="line">      <span class="comment">// 处理当 A的update过程中调用了B的setState方法的情况</span></span><br><span class="line">      dirtyComponents.splice(<span class="number">0</span>, <span class="keyword">this</span>.dirtyComponentsLength);</span><br><span class="line">      flushBatchedUpdates();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dirtyComponents.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Wrapper2号定义</span></span><br><span class="line"><span class="keyword">var</span> UPDATE_QUEUEING = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackQueue.reset();</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackQueue.notifyAll();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">ReactUpdatesFlushTransaction.prototype.perform = <span class="function"><span class="keyword">function</span> (<span class="params">method, scope, a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用ReactReconcileTransaction去调用runBatchedUpdates方法</span></span><br><span class="line">  <span class="keyword">return</span> Transaction.perform.call(<span class="keyword">this</span>, <span class="keyword">this</span>.reconcileTransaction.perform, <span class="keyword">this</span>.reconcileTransaction, method, scope, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就到了我们执行更新操作的那位选手<code>ReactReconcileTransaction</code></p>
<h4 id="ReactReconcileTransaction的实现以及功能"><a href="#ReactReconcileTransaction的实现以及功能" class="headerlink" title="ReactReconcileTransaction的实现以及功能"></a>ReactReconcileTransaction的实现以及功能</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SELECTION_RESTORATION = &#123;</span><br><span class="line">  initialize: ReactInputSelection.getSelectionInformation,</span><br><span class="line">  close: ReactInputSelection.restoreSelection,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> EVENT_SUPPRESSION = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentlyEnabled = ReactBrowserEventEmitter.isEnabled();</span><br><span class="line">    ReactBrowserEventEmitter.setEnabled(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> currentlyEnabled;</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params">previouslyEnabled</span>) </span>&#123;</span><br><span class="line">    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> ON_DOM_READY_QUEUEING = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reactMountReady.reset();</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reactMountReady.notifyAll();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [</span><br><span class="line">  SELECTION_RESTORATION,</span><br><span class="line">  EVENT_SUPPRESSION,</span><br><span class="line">  ON_DOM_READY_QUEUEING,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>至此整个事务调用结束 由batchingTransaction -&gt; FlushTransaction -&gt; ReconcileTransaction去调用了<code>ReactUpdates.runBatchedUpdates</code>方法, 然后分别处理了<code>callback</code>, <code>DOM事件</code>等一系列事务调用.</p>
<h4 id="下节预告-React中的事件机制"><a href="#下节预告-React中的事件机制" class="headerlink" title="下节预告: React中的事件机制."></a>下节预告: React中的事件机制.</h4></div></article></div></main><footer><div class="paginator"><a href="/2019/03/10/Rust 的类型系统/" class="prev">上一篇</a><a href="/2018/08/04/React源码阅读系列-§2.2-从虚拟DOM到真实DOM/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'jeremywuuuuu';
var disqus_identifier = '2018/08/06/React源码阅读系列-§2.3-事务机制/';
var disqus_title = 'React源码阅读系列-§2.3-事务机制';
var disqus_url = 'https://jeremywu.info/2018/08/06/React源码阅读系列-§2.3-事务机制/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//jeremywuuuuu.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2019 <a href="https://jeremywu.info">Jeremy Wu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>