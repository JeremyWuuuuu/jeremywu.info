<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> React源码阅读系列-§1.4-来人, 给我new一下 · Jeremy's Note</title><meta name="description" content="自定义组件的实例化"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://jeremywu.info/atom.xml" title="Jeremy's Note"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/JeremyWuuuuu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">React源码阅读系列-§1.4-来人, 给我new一下</h1><div class="post-info">2018年7月21日</div><div class="post-content"><p><strong>关键字: </strong> <code>ReactCompositeComponent</code> <code>instantiate</code></p>
<h3 id="让我们先实例化一个组件"><a href="#让我们先实例化一个组件" class="headerlink" title="让我们先实例化一个组件"></a>让我们先实例化一个组件</h3><p><a href="/2018/07/20/React源码阅读系列-§1.3先给我整一个Component/">上一章</a>讲到了, React的<code>Component</code>种类, 但没讲到用户自己写的<code>CustomComponent</code>是怎么被实例化的. 在后面的章节会介绍到关于应用启动的过程到底发生了哪些事情, 在这边就先简单的做一个铺垫. 主要关注在<code>CustomComponent</code>的实例化过程.</p>
<a id="more"></a>
<p>当我们调用<code>React.render(...)</code>方法的时候, 会调用<a href="https://github.com/facebook/react/blob/v15.6.2/src/renderers/shared/stack/reconciler/instantiateReactComponent.js" target="_blank" rel="noopener">ReactMount.js</a>中的<code>instantiateReactComponent</code>方法, 该方法中涉及到实例化一个<code>CustomComponent</code>的代码为:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">node, shouldHaveDebugID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> element.type === <span class="string">'string'</span>) &#123;</span><br><span class="line">        instance = ReactHostComponent.createInternalComponent(element);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInternalComponentType(element.type)) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> element.type(element);</span><br><span class="line">        <span class="keyword">if</span> (!instance.getHostNode) &#123;</span><br><span class="line">          instance.getHostNode = instance.getNativeNode;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> ReactCompositeComponentWrapper(element);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">'string'</span> || <span class="keyword">typeof</span> node === <span class="string">'number'</span>) &#123;</span><br><span class="line">        instance = ReactHostComponent.createInstanceForText(node);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Encountered invalid React node of type "</span> + <span class="keyword">typeof</span> node );</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>关键的一行代码在此处:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> ReactCompositeComponentWrapper(element);</span><br></pre></td></tr></table></figure></p>
<p>关键角色<code>ReactCompositeComponentWrapper</code>是干什么的呢? 又和我们提到的<code>ReactCompositeComponent</code>有什么纠缠不清的关系呢? 下面几行代码就可以告诉你事情的真相:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactCompositeComponentWrapper = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.construct(element);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">  ReactCompositeComponentWrapper.prototype,</span><br><span class="line">  ReactCompositeComponent,</span><br><span class="line">  &#123;</span><br><span class="line">    _instantiateReactComponent: instantiateReactComponent,</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p><code>ReactCompositeComponentWrapper</code>就跟他的名字一样, 是对<code>ReactCompositeComponent</code>这个类的一个包装类, 所有的类方法都来自于我们今天要说到的主角<code>ReactCompositeComponent</code>.</p>
<hr>
<h3 id="ReactCompositeComponent"><a href="#ReactCompositeComponent" class="headerlink" title="ReactCompositeComponent"></a><code>ReactCompositeComponent</code></h3><p>源码地址: <a href="https://github.com/facebook/react/blob/v15.6.2/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js" target="_blank" rel="noopener">ReactCompositeComponent.js</a></p>
<p>下面接着对<code>ReactCompositeComponent</code>做一下分析, 某些方法的具体内容会省略掉, 如果有需要可以自行查阅源码当中的具体代码, 方便节省篇幅以及更易于阅读.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactCompositeComponent = &#123;</span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;, <span class="comment">// 用于初始化组件的元信息(Metadata)</span></span><br><span class="line">  mountComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inst = <span class="keyword">this</span>._constructComponent(...); <span class="comment">// 生命周期函数的启动入口,</span></span><br><span class="line">    <span class="keyword">var</span> markup; <span class="comment">// render方法返回的ReactElement就是这个markup</span></span><br><span class="line">    markup = performInitialMount(...);</span><br><span class="line">    <span class="keyword">if</span> (inst.componentDidMount) inst.componentDidMount(); <span class="comment">// 第三个钩子函数调用</span></span><br><span class="line">    <span class="keyword">return</span> markup;</span><br><span class="line">  &#125;,</span><br><span class="line">  _constructComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;, <span class="comment">// 这个方法会调用下面这个方法</span></span><br><span class="line">  _constructComponentWithoutOwner: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Component(publicProps, publicContext, updateQueue); <span class="comment">// 被包起来的Component被实例化</span></span><br><span class="line">  &#125;,</span><br><span class="line">  performInitialMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ins = <span class="keyword">this</span>._instance;</span><br><span class="line">    <span class="keyword">if</span> (ins.componentWillMount) ins.componentWillMount(); <span class="comment">// 第一个钩子函数的调用</span></span><br><span class="line">    <span class="comment">// 比较重要的地方: 当在初始挂载的阶段如果有发现`setState`方法被调用, 便会通过同步的方式来处理, 很好的避免了setState导致的重新渲染, 来提高整体的性能.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._pendingStateQueue) &#123;</span><br><span class="line">      inst.state = <span class="keyword">this</span>._processPendingState(inst.props, inst.context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (renderedElement === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// 近似等于: renderedElement = this._instance.render();</span></span><br><span class="line">      renderedElement = <span class="keyword">this</span>._renderValidatedComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> child = <span class="keyword">this</span>._instantiateReactComponent(...) <span class="comment">// 递归实例化子组件</span></span><br><span class="line">    <span class="keyword">var</span> markup = ReactReconciler.mountComponent(child, ...); <span class="comment">// 递归得到完整的树.</span></span><br><span class="line">    <span class="keyword">return</span> markup;</span><br><span class="line">  &#125;,</span><br><span class="line">  _renderValidatedComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._renderValidatedComponentWithoutOwnerOrContext();</span><br><span class="line">  &#125;,</span><br><span class="line">  _renderValidatedComponentWithoutOwnerOrContext: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._instance.render(); <span class="comment">// 第二个钩子的调用</span></span><br><span class="line">  &#125;,</span><br><span class="line">  receiveComponent: <span class="function"><span class="keyword">function</span>(<span class="params">...</span>) </span>&#123; <span class="comment">// 调用该方法来更新Component</span></span><br><span class="line">    <span class="keyword">this</span>.updateComponent(...); </span><br><span class="line">  &#125;,</span><br><span class="line">  updateComponent: <span class="function"><span class="keyword">function</span>(<span class="params">...</span>) </span>&#123; <span class="comment">// 后面会讲到这些更新条件如何被满足</span></span><br><span class="line">    <span class="keyword">if</span> (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123;</span><br><span class="line">      inst.componentWillReceiveProps(); <span class="comment">// 第四个钩子函数的调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> shouldUpdate = inst.shouldComponentUpdate(); <span class="comment">// 第五个钩子函数调用</span></span><br><span class="line">    <span class="keyword">if</span> (shouldUpdate) <span class="keyword">this</span>._performComponentUpdate();</span><br><span class="line">  &#125;,</span><br><span class="line">  _performComponentUpdate: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    inst.componentWillUpdate(...); <span class="comment">// 第六个钩子函数的调用.</span></span><br><span class="line">    <span class="keyword">this</span>._updateRenderedComponent(...); <span class="comment">// 更新; 内部调用第七个钩子函数 Component.render();</span></span><br><span class="line">    inst.componentDidUpdate &amp;&amp; inst.componentDidUpdate(); <span class="comment">// 第八个个钩子函数调用</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 里面是Component更新的操作 简单来说就是销毁掉原有的节点, 然后重新实例化新的节点挂载.</span></span><br><span class="line">  _updateRenderedComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">  unmountComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 递归卸载节点, 调用子节点的 componentWillUnmount方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结:"></a>本章小结:</h4><p><code>ReactCompositeComponent</code> 的内容基本就是挂载/更新/卸载等操作. 除了<code>CompositeComponent</code>, 在<code>instantiateReactComponent</code>方法中, 能够看到React中一共有4种Component类型.</p>
<ol>
<li>ReactCompositeComponent<ul>
<li>InternalComponent. <code>// 可以理解为React的官方标准组件库</code></li>
<li>UserDefinedComponent <code>// 用户自定义</code></li>
</ul>
</li>
<li>ReactDOMComponent <code>// DOM节点相关的Component, 自定义的Component最后都会被处理成该类型的</code></li>
<li>ReactTextComponent <code>// 字面量节点, 如 &quot;Some string&quot; &quot;12312&quot;</code></li>
<li>ReactEmptyComponent <code>// 空节点</code></li>
</ol>
<hr>
<h4 id="下期预告-从React-render-的调用开始-到底发生了什么"><a href="#下期预告-从React-render-的调用开始-到底发生了什么" class="headerlink" title="下期预告: 从React.render()的调用开始, 到底发生了什么?"></a>下期预告: 从<code>React.render()</code>的调用开始, 到底发生了什么?</h4></div></article></div></main><footer><div class="paginator"><a href="/2018/07/20/React源码阅读系列-§1.3先给我整一个Component/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'jeremywuuuuu';
var disqus_identifier = '2018/07/21/React源码阅读系列-§1-4-来人-给我new一下/';
var disqus_title = 'React源码阅读系列-§1.4-来人, 给我new一下';
var disqus_url = 'https://jeremywu.info/2018/07/21/React源码阅读系列-§1-4-来人-给我new一下/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//jeremywuuuuu.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="https://jeremywu.info">Jeremy Wu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>